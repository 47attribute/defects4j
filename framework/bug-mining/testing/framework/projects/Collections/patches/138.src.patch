diff --git a/src/main/java/org/apache/commons/collections4/BagUtils.java b/src/main/java/org/apache/commons/collections4/BagUtils.java
index c0e39634..cfa79677 100644
--- a/src/main/java/org/apache/commons/collections4/BagUtils.java
+++ b/src/main/java/org/apache/commons/collections4/BagUtils.java
@@ -79,7 +79,7 @@ public class BagUtils {
      * @param <E> the element type
      * @param bag the bag to synchronize, must not be null
      * @return a synchronized bag backed by that bag
-     * @throws NullPointerException if the Bag is null
+     * @throws IllegalArgumentException if the Bag is null
      */
     public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {
         return SynchronizedBag.synchronizedBag(bag);
@@ -92,7 +92,7 @@ public class BagUtils {
      * @param <E> the element type
      * @param bag the bag whose unmodifiable view is to be returned, must not be null
      * @return an unmodifiable view of that bag
-     * @throws NullPointerException if the Bag is null
+     * @throws IllegalArgumentException if the Bag is null
      */
     public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {
         return UnmodifiableBag.unmodifiableBag(bag);
@@ -111,7 +111,7 @@ public class BagUtils {
      * @param bag the bag to predicate, must not be null
      * @param predicate the predicate for the bag, must not be null
      * @return a predicated bag backed by the given bag
-     * @throws NullPointerException if the Bag or Predicate is null
+     * @throws IllegalArgumentException if the Bag or Predicate is null
      */
     public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {
         return PredicatedBag.predicatedBag(bag, predicate);
@@ -131,7 +131,7 @@ public class BagUtils {
      * @param bag the bag to predicate, must not be null
      * @param transformer the transformer for the bag, must not be null
      * @return a transformed bag backed by the given bag
-     * @throws NullPointerException if the Bag or Transformer is null
+     * @throws IllegalArgumentException if the Bag or Transformer is null
      */
     public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {
         return TransformedBag.transformingBag(bag, transformer);
@@ -143,7 +143,7 @@ public class BagUtils {
      * @param <E> the element type
      * @param bag the bag to decorate, must not be null
      * @return a Bag that complies to the Collection contract
-     * @throws NullPointerException if bag is null
+     * @throws IllegalArgumentException if bag is null
      * @since 4.0
      */
     public static <E> Bag<E> collectionBag(final Bag<E> bag) {
@@ -175,7 +175,7 @@ public class BagUtils {
      * @param <E> the element type
      * @param bag the bag to synchronize, must not be null
      * @return a synchronized bag backed by that bag
-     * @throws NullPointerException if the SortedBag is null
+     * @throws IllegalArgumentException if the SortedBag is null
      */
     public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {
         return SynchronizedSortedBag.synchronizedSortedBag(bag);
@@ -189,7 +189,7 @@ public class BagUtils {
      * @param <E> the element type
      * @param bag the bag whose unmodifiable view is to be returned, must not be null
      * @return an unmodifiable view of that bag
-     * @throws NullPointerException if the SortedBag is null
+     * @throws IllegalArgumentException if the SortedBag is null
      */
     public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {
         return UnmodifiableSortedBag.unmodifiableSortedBag(bag);
@@ -209,7 +209,7 @@ public class BagUtils {
      * @param bag the sorted bag to predicate, must not be null
      * @param predicate the predicate for the bag, must not be null
      * @return a predicated bag backed by the given bag
-     * @throws NullPointerException if the SortedBag or Predicate is null
+     * @throws IllegalArgumentException if the SortedBag or Predicate is null
      */
     public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,
             final Predicate<? super E> predicate) {
@@ -231,7 +231,7 @@ public class BagUtils {
      * @param bag the bag to predicate, must not be null
      * @param transformer the transformer for the bag, must not be null
      * @return a transformed bag backed by the given bag
-     * @throws NullPointerException if the Bag or Transformer is null
+     * @throws IllegalArgumentException if the Bag or Transformer is null
      */
     public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,
                                                          final Transformer<? super E, ? extends E> transformer) {
diff --git a/src/main/java/org/apache/commons/collections4/ClosureUtils.java b/src/main/java/org/apache/commons/collections4/ClosureUtils.java
index b339a1a0..c7c38ddf 100644
--- a/src/main/java/org/apache/commons/collections4/ClosureUtils.java
+++ b/src/main/java/org/apache/commons/collections4/ClosureUtils.java
@@ -125,7 +125,7 @@ public class ClosureUtils {
      * @param predicate  the predicate to use as an end of loop test, not null
      * @param closure  the closure to call repeatedly, not null
      * @return the <code>while</code> closure
-     * @throws NullPointerException if either argument is null
+     * @throws IllegalArgumentException if either argument is null
      */
     public static <E> Closure<E> whileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure) {
         return WhileClosure.<E>whileClosure(predicate, closure, false);
@@ -141,7 +141,7 @@ public class ClosureUtils {
      * @param closure  the closure to call repeatedly, not null
      * @param predicate  the predicate to use as an end of loop test, not null
      * @return the <code>do-while</code> closure
-     * @throws NullPointerException if either argument is null
+     * @throws IllegalArgumentException if either argument is null
      */
     public static <E> Closure<E> doWhileClosure(final Closure<? super E> closure,
                                                 final Predicate<? super E> predicate) {
@@ -158,7 +158,7 @@ public class ClosureUtils {
      * @param <E>  the type that the closure acts on
      * @param methodName  the name of the method
      * @return the <code>invoker</code> closure
-     * @throws NullPointerException if the method name is null
+     * @throws IllegalArgumentException if the method name is null
      */
     public static <E> Closure<E> invokerClosure(final String methodName) {
         // reuse transformer as it has caching - this is lazy really, should have inner class here
@@ -177,7 +177,7 @@ public class ClosureUtils {
      * @param paramTypes  the parameter types
      * @param args  the arguments
      * @return the <code>invoker</code> closure
-     * @throws NullPointerException if the method name is null
+     * @throws IllegalArgumentException if the method name is null
      * @throws IllegalArgumentException if the paramTypes and args don't match
      */
     public static <E> Closure<E> invokerClosure(final String methodName, final Class<?>[] paramTypes,
@@ -195,8 +195,8 @@ public class ClosureUtils {
      * @param <E>  the type that the closure acts on
      * @param closures  an array of closures to chain
      * @return the <code>chained</code> closure
-     * @throws NullPointerException if the closures array is null
-     * @throws NullPointerException if any closure in the array is null
+     * @throws IllegalArgumentException if the closures array is null
+     * @throws IllegalArgumentException if any closure in the array is null
      */
     public static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {
         return ChainedClosure.chainedClosure(closures);
@@ -212,9 +212,9 @@ public class ClosureUtils {
      * @param <E>  the type that the closure acts on
      * @param closures  a collection of closures to chain
      * @return the <code>chained</code> closure
-     * @throws NullPointerException if the closures collection is null
-     * @throws NullPointerException if any closure in the collection is null
+     * @throws IllegalArgumentException if the closures collection is null
      * @throws IllegalArgumentException if the closures collection is empty
+     * @throws IllegalArgumentException if any closure in the collection is null
      */
     public static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {
         return ChainedClosure.chainedClosure(closures);
@@ -230,7 +230,8 @@ public class ClosureUtils {
      * @param predicate  the validating predicate
      * @param trueClosure  the closure called if the predicate is true
      * @return the <code>if</code> closure
-     * @throws NullPointerException if the predicate or closure is null
+     * @throws IllegalArgumentException if the predicate is null
+     * @throws IllegalArgumentException if the closure is null
      * @since 3.2
      */
     public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,
@@ -249,7 +250,8 @@ public class ClosureUtils {
      * @param trueClosure  the closure called if the predicate is true
      * @param falseClosure  the closure called if the predicate is false
      * @return the <code>switch</code> closure
-     * @throws NullPointerException if the predicate or either closure is null
+     * @throws IllegalArgumentException if the predicate is null
+     * @throws IllegalArgumentException if either closure is null
      */
     public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,
                                            final Closure<? super E> trueClosure,
@@ -271,9 +273,9 @@ public class ClosureUtils {
      * @param predicates  an array of predicates to check, not null
      * @param closures  an array of closures to call, not null
      * @return the <code>switch</code> closure
-     * @throws NullPointerException if the either array is null
-     * @throws NullPointerException if any element in the arrays is null
-     * @throws IllegalArgumentException if the arrays have different sizes
+     * @throws IllegalArgumentException if the either array is null
+     * @throws IllegalArgumentException if any element in the arrays is null
+     * @throws IllegalArgumentException if the arrays are different sizes
      */
     public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates,
                                                final Closure<? super E>[] closures) {
@@ -296,8 +298,8 @@ public class ClosureUtils {
      * @param closures  an array of closures to call, not null
      * @param defaultClosure  the default to call if no predicate matches
      * @return the <code>switch</code> closure
-     * @throws NullPointerException if the either array is null
-     * @throws NullPointerException if any element in the arrays is null
+     * @throws IllegalArgumentException if the either array is null
+     * @throws IllegalArgumentException if any element in the arrays is null
      * @throws IllegalArgumentException if the arrays are different sizes
      */
     public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates,
@@ -322,9 +324,9 @@ public class ClosureUtils {
      * @param <E>  the type that the closure acts on
      * @param predicatesAndClosures  a map of predicates to closures
      * @return the <code>switch</code> closure
-     * @throws NullPointerException if the map is null
-     * @throws NullPointerException if any closure in the map is null
+     * @throws IllegalArgumentException if the map is null
      * @throws IllegalArgumentException if the map is empty
+     * @throws IllegalArgumentException if any closure in the map is null
      * @throws ClassCastException  if the map elements are of the wrong type
      */
     public static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {
@@ -345,14 +347,14 @@ public class ClosureUtils {
      * @param <E>  the type that the closure acts on
      * @param objectsAndClosures  a map of objects to closures
      * @return the closure
-     * @throws NullPointerException if the map is null
-     * @throws NullPointerException if any closure in the map is null
+     * @throws IllegalArgumentException if the map is null
      * @throws IllegalArgumentException if the map is empty
+     * @throws IllegalArgumentException if any closure in the map is null
      */
     @SuppressWarnings("unchecked")
     public static <E> Closure<E> switchMapClosure(final Map<? extends E, Closure<E>> objectsAndClosures) {
         if (objectsAndClosures == null) {
-            throw new NullPointerException("The object and closure map must not be null");
+            throw new IllegalArgumentException("The object and closure map must not be null");
         }
         final Closure<? super E> def = objectsAndClosures.remove(null);
         final int size = objectsAndClosures.size();
diff --git a/src/main/java/org/apache/commons/collections4/CollectionUtils.java b/src/main/java/org/apache/commons/collections4/CollectionUtils.java
index 5012fa0d..32ca11b0 100644
--- a/src/main/java/org/apache/commons/collections4/CollectionUtils.java
+++ b/src/main/java/org/apache/commons/collections4/CollectionUtils.java
@@ -545,14 +545,14 @@ public class CollectionUtils {
      * @param b  the second collection, must not be null
      * @param equator  the Equator used for testing equality
      * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.
-     * @throws NullPointerException if the equator is null
+     * @throws IllegalArgumentException if the equator is null
      * @since 4.0
      */
     public static <E> boolean isEqualCollection(final Collection<? extends E> a,
                                                 final Collection<? extends E> b,
                                                 final Equator<? super E> equator) {
         if (equator == null) {
-            throw new NullPointerException("Equator must not be null.");
+            throw new IllegalArgumentException("equator may not be null");
         }
 
         if(a.size() != b.size()) {
@@ -1509,7 +1509,7 @@ public class CollectionUtils {
      * @param a  the first collection, must not be null
      * @param b  the second collection, must not be null
      * @return a new sorted List, containing the elements of Collection a and b
-     * @throws NullPointerException if either collection is null
+     * @throws IllegalArgumentException if either collection is null
      * @since 4.0
      */
     public static <O extends Comparable<? super O>> List<O> collate(Iterable<? extends O> a,
@@ -1529,7 +1529,7 @@ public class CollectionUtils {
      * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise
      *   they will be removed in the output collection
      * @return a new sorted List, containing the elements of Collection a and b
-     * @throws NullPointerException if either collection is null
+     * @throws IllegalArgumentException if either collection is null
      * @since 4.0
      */
     public static <O extends Comparable<? super O>> List<O> collate(final Iterable<? extends O> a,
@@ -1549,7 +1549,7 @@ public class CollectionUtils {
      * @param b  the second collection, must not be null
      * @param c  the comparator to use for the merge.
      * @return a new sorted List, containing the elements of Collection a and b
-     * @throws NullPointerException if either collection or the comparator is null
+     * @throws IllegalArgumentException if either collection or the comparator is null
      * @since 4.0
      */
     public static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b,
@@ -1570,17 +1570,17 @@ public class CollectionUtils {
      * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise
      *   they will be removed in the output collection
      * @return a new sorted List, containing the elements of Collection a and b
-     * @throws NullPointerException if either collection or the comparator is null
+     * @throws IllegalArgumentException if either collection or the comparator is null
      * @since 4.0
      */
     public static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b,
                                       final Comparator<? super O> c, final boolean includeDuplicates) {
 
         if (a == null || b == null) {
-            throw new NullPointerException("The collections must not be null");
+            throw new IllegalArgumentException("The collections must not be null");
         }
         if (c == null) {
-            throw new NullPointerException("The comparator must not be null");
+            throw new IllegalArgumentException("The comparator must not be null");
         }
 
         // if both Iterables are a Collection, we can estimate the size
@@ -1807,7 +1807,7 @@ public class CollectionUtils {
      * @param <C>  the type of object the {@link Collection} contains
      * @param collection  the collection to synchronize, must not be null
      * @return a synchronized collection backed by the given collection
-     * @throws NullPointerException if the collection is null
+     * @throws IllegalArgumentException  if the collection is null
      * @deprecated since 4.1, use {@link java.util.Collections#synchronizedCollection(Collection)} instead
      */
     @Deprecated
@@ -1823,7 +1823,7 @@ public class CollectionUtils {
      * @param <C>  the type of object the {@link Collection} contains
      * @param collection  the collection to make unmodifiable, must not be null
      * @return an unmodifiable collection backed by the given collection
-     * @throws NullPointerException if the collection is null
+     * @throws IllegalArgumentException  if the collection is null
      * @deprecated since 4.1, use {@link java.util.Collections#unmodifiableCollection(Collection)} instead
      */
     @Deprecated
@@ -1839,11 +1839,11 @@ public class CollectionUtils {
      * It is important not to use the original collection after invoking this method,
      * as it is a backdoor for adding invalid objects.
      *
-     * @param <C> the type of objects in the Collection.
      * @param collection  the collection to predicate, must not be null
      * @param predicate  the predicate for the collection, must not be null
+     * @param <C> the type of objects in the Collection.
      * @return a predicated collection backed by the given collection
-     * @throws NullPointerException if the Collection is null
+     * @throws IllegalArgumentException  if the Collection is null
      */
     public static <C> Collection<C> predicatedCollection(final Collection<C> collection,
                                                          final Predicate<? super C> predicate) {
@@ -1860,11 +1860,11 @@ public class CollectionUtils {
      * Existing entries in the specified collection will not be transformed.
      * If you want that behaviour, see {@link TransformedCollection#transformedCollection}.
      *
-     * @param <E> the type of object the {@link Collection} contains
+     * @param <E>  the type of object the {@link Collection} contains
      * @param collection  the collection to predicate, must not be null
      * @param transformer  the transformer for the collection, must not be null
      * @return a transformed collection backed by the given collection
-     * @throws NullPointerException if the Collection or Transformer is null
+     * @throws IllegalArgumentException  if the Collection or Transformer is null
      */
     public static <E> Collection<E> transformingCollection(final Collection<E> collection,
             final Transformer<? super E, ? extends E> transformer) {
@@ -1876,15 +1876,11 @@ public class CollectionUtils {
      * @param <E> collection type
      * @param collection to read
      * @return sole member of collection
-     * @throws NullPointerException if collection is null
-     * @throws IllegalArgumentException if collection is empty or contains more than one element
+     * @throws IllegalArgumentException if collection is null/empty or contains more than one element
      * @since 4.0
      */
     public static <E> E extractSingleton(final Collection<E> collection) {
-        if (collection == null) {
-            throw new NullPointerException("Collection must not be null.");
-        }
-        if (collection.size() != 1) {
+        if (collection == null || collection.size() != 1) {
             throw new IllegalArgumentException("Can extract singleton only when collection size == 1");
         }
         return collection.iterator().next();
diff --git a/src/main/java/org/apache/commons/collections4/FactoryUtils.java b/src/main/java/org/apache/commons/collections4/FactoryUtils.java
index bb5887f8..5a6263b9 100644
--- a/src/main/java/org/apache/commons/collections4/FactoryUtils.java
+++ b/src/main/java/org/apache/commons/collections4/FactoryUtils.java
@@ -115,7 +115,7 @@ public class FactoryUtils {
      * @param <T> the type that the factory creates
      * @param classToInstantiate  the Class to instantiate each time in the factory
      * @return the <code>reflection</code> factory
-     * @throws NullPointerException if the classToInstantiate is null
+     * @throws IllegalArgumentException if the classToInstantiate is null
      */
     public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate) {
         return InstantiateFactory.instantiateFactory(classToInstantiate, null, null);
@@ -132,7 +132,7 @@ public class FactoryUtils {
      * @param paramTypes  parameter types for the constructor, can be null
      * @param args  the arguments to pass to the constructor, can be null
      * @return the <code>reflection</code> factory
-     * @throws NullPointerException if the classToInstantiate is null
+     * @throws IllegalArgumentException if the classToInstantiate is null
      * @throws IllegalArgumentException if the paramTypes and args don't match
      * @throws IllegalArgumentException if the constructor doesn't exist
      */
diff --git a/src/main/java/org/apache/commons/collections4/IteratorUtils.java b/src/main/java/org/apache/commons/collections4/IteratorUtils.java
index b8e8c4c1..85dbe87c 100644
--- a/src/main/java/org/apache/commons/collections4/IteratorUtils.java
+++ b/src/main/java/org/apache/commons/collections4/IteratorUtils.java
@@ -430,8 +430,7 @@ public class IteratorUtils {
      * @param iterator  the iterator to decorate
      * @param max  the maximum number of elements returned by this iterator
      * @return a new bounded iterator
-     * @throws NullPointerException if the iterator is null
-     * @throws IllegalArgumentException if max is negative
+     * @throws IllegalArgumentException if the iterator is null or max is negative
      * @since 4.1
      */
     public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long max) {
@@ -451,8 +450,7 @@ public class IteratorUtils {
      * @param offset  the index of the first element of the decorated iterator to return
      * @param max  the maximum number of elements returned by this iterator
      * @return a new bounded iterator
-     * @throws NullPointerException if the iterator is null
-     * @throws IllegalArgumentException if either offset or max is negative
+     * @throws IllegalArgumentException if the iterator is null or either offset or max is negative
      * @since 4.1
      */
     public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator,
diff --git a/src/main/java/org/apache/commons/collections4/ListUtils.java b/src/main/java/org/apache/commons/collections4/ListUtils.java
index 605bde35..89e834d9 100644
--- a/src/main/java/org/apache/commons/collections4/ListUtils.java
+++ b/src/main/java/org/apache/commons/collections4/ListUtils.java
@@ -80,7 +80,7 @@ public class ListUtils {
      * Returns a new list containing all elements that are contained in
      * both given lists.
      *
-     * @param <E> the element type
+     * @param <E>  the element type
      * @param list1  the first list
      * @param list2  the second list
      * @return  the intersection of those two lists
@@ -117,10 +117,10 @@ public class ListUtils {
      * contains one occurrence, then the returned list will still contain
      * one occurrence.
      *
-     * @param <E> the element type
+     * @param <E>  the element type
      * @param list1  the list to subtract from
      * @param list2  the list to subtract
-     * @return a new list containing the results
+     * @return  a new list containing the results
      * @throws NullPointerException if either list is null
      */
     public static <E> List<E> subtract(final List<E> list1, final List<? extends E> list2) {
@@ -138,7 +138,7 @@ public class ListUtils {
      * Returns the sum of the given lists.  This is their intersection
      * subtracted from their union.
      *
-     * @param <E> the element type
+     * @param <E>  the element type
      * @param list1  the first list
      * @param list2  the second list
      * @return  a new list containing the sum of those lists
@@ -153,10 +153,10 @@ public class ListUtils {
      * first list.  The {@link List#addAll(Collection)} operation is
      * used to append the two given lists into a new list.
      *
-     * @param <E> the element type
+     * @param <E>  the element type
      * @param list1  the first list
      * @param list2  the second list
-     * @return a new list containing the union of those lists
+     * @return  a new list containing the union of those lists
      * @throws NullPointerException if either list is null
      */
     public static <E> List<E> union(final List<? extends E> list1, final List<? extends E> list2) {
@@ -171,11 +171,14 @@ public class ListUtils {
      * <p>
      * A <code>null</code> predicate matches no elements.
      *
-     * @param <E> the element type
-     * @param inputCollection  the collection to get the input from, may not be null
-     * @param predicate  the predicate to use, may be null
+     * @param <E>  the element type
+     * @param inputCollection
+     *            the collection to get the input from, may not be null
+     * @param predicate
+     *            the predicate to use, may be null
      * @return the elements matching the predicate (new list)
-     * @throws NullPointerException if the input list is null
+     * @throws NullPointerException
+     *             if the input list is null
      *
      * @since 4.0
      * @see CollectionUtils#select(Iterable, Predicate)
@@ -189,13 +192,17 @@ public class ListUtils {
      * Selects all elements from inputCollection which don't match the given
      * predicate into an output collection.
      * <p>
-     * If the input predicate is <code>null</code>, the result is an empty list.
+     * If the input predicate is <code>null</code>, the result is an empty
+     * list.
      *
-     * @param <E> the element type
-     * @param inputCollection the collection to get the input from, may not be null
-     * @param predicate the predicate to use, may be null
+     * @param <E>  the element type
+     * @param inputCollection
+     *            the collection to get the input from, may not be null
+     * @param predicate
+     *            the predicate to use, may be null
      * @return the elements <b>not</b> matching the predicate (new list)
-     * @throws NullPointerException if the input collection is null
+     * @throws NullPointerException
+     *             if the input collection is null
      *
      * @since 4.0
      * @see CollectionUtils#selectRejected(Iterable, Predicate)
@@ -371,10 +378,10 @@ public class ListUtils {
      *
      * This method is just a wrapper for {@link Collections#synchronizedList(List)}.
      *
-     * @param <E> the element type
+     * @param <E>  the element type
      * @param list  the list to synchronize, must not be null
      * @return a synchronized list backed by the given list
-     * @throws NullPointerException if the list is null
+     * @throws IllegalArgumentException  if the list is null
      */
     public static <E> List<E> synchronizedList(final List<E> list) {
         return Collections.synchronizedList(list);
@@ -388,7 +395,7 @@ public class ListUtils {
      * @param <E>  the element type
      * @param list  the list to make unmodifiable, must not be null
      * @return an unmodifiable list backed by the given list
-     * @throws NullPointerException if the list is null
+     * @throws IllegalArgumentException  if the list is null
      */
     public static <E> List<E> unmodifiableList(final List<? extends E> list) {
         return UnmodifiableList.unmodifiableList(list);
@@ -402,11 +409,11 @@ public class ListUtils {
      * It is important not to use the original list after invoking this method,
      * as it is a backdoor for adding invalid objects.
      *
-     * @param <E> the element type
+     * @param <E>  the element type
      * @param list  the list to predicate, must not be null
      * @param predicate  the predicate for the list, must not be null
      * @return a predicated list backed by the given list
-     * @throws NullPointerException if the List or Predicate is null
+     * @throws IllegalArgumentException  if the List or Predicate is null
      */
     public static <E> List<E> predicatedList(final List<E> list, final Predicate<E> predicate) {
         return PredicatedList.predicatedList(list, predicate);
@@ -426,11 +433,11 @@ public class ListUtils {
      * Existing entries in the specified list will not be transformed.
      * If you want that behaviour, see {@link TransformedList#transformedList}.
      *
-     * @param <E> the element type
+     * @param <E>  the element type
      * @param list  the list to predicate, must not be null
      * @param transformer  the transformer for the list, must not be null
      * @return a transformed list backed by the given list
-     * @throws NullPointerException if the List or Transformer is null
+     * @throws IllegalArgumentException  if the List or Transformer is null
      */
     public static <E> List<E> transformedList(final List<E> list,
                                               final Transformer<? super E, ? extends E> transformer) {
@@ -461,11 +468,11 @@ public class ListUtils {
      * instance is the fourth element in the list.  The first, second,
      * and third element are all set to <code>null</code>.
      *
-     * @param <E> the element type
+     * @param <E>  the element type
      * @param list  the list to make lazy, must not be null
      * @param factory  the factory for creating new objects, must not be null
      * @return a lazy list backed by the given list
-     * @throws NullPointerException if the List or Factory is null
+     * @throws IllegalArgumentException  if the List or Factory is null
      */
     public static <E> List<E> lazyList(final List<E> list, final Factory<? extends E> factory) {
         return LazyList.lazyList(list, factory);
@@ -480,7 +487,7 @@ public class ListUtils {
      * @param <E>  the element type
      * @param list  the list whose size to fix, must not be null
      * @return a fixed-size list backed by that list
-     * @throws NullPointerException  if the List is null
+     * @throws IllegalArgumentException  if the List is null
      */
     public static <E> List<E> fixedSizeList(final List<E> list) {
         return FixedSizeList.fixedSizeList(list);
@@ -518,7 +525,7 @@ public class ListUtils {
      * @param a  the first list
      * @param b  the second list
      * @return the longest common subsequence
-     * @throws NullPointerException if either list is {@code null}
+     * @throws IllegalArgumentException if either list is {@code null}
      * @since 4.0
      */
     public static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b) {
@@ -533,16 +540,16 @@ public class ListUtils {
      * @param b  the second list
      * @param equator  the equator used to test object equality
      * @return the longest common subsequence
-     * @throws NullPointerException if either list or the equator is {@code null}
+     * @throws IllegalArgumentException if either list or the equator is {@code null}
      * @since 4.0
      */
     public static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b,
                                                        final Equator<? super E> equator) {
         if (a == null || b == null) {
-            throw new NullPointerException("List must not be null");
+            throw new IllegalArgumentException("List must not be null");
         }
         if (equator == null) {
-          throw new NullPointerException("Equator must not be null");
+          throw new IllegalArgumentException("Equator must not be null");
         }
 
         final SequencesComparator<E> comparator = new SequencesComparator<E>(a, b, equator);
@@ -561,12 +568,12 @@ public class ListUtils {
      * @param a  the first sequence
      * @param b  the second sequence
      * @return the longest common subsequence as {@link String}
-     * @throws NullPointerException if either sequence is {@code null}
+     * @throws IllegalArgumentException if either sequence is {@code null}
      * @since 4.0
      */
     public static String longestCommonSubsequence(final CharSequence a, final CharSequence b) {
         if (a == null || b == null) {
-            throw new NullPointerException("CharSequence must not be null");
+            throw new IllegalArgumentException("CharSequence must not be null");
         }
         final List<Character> lcs = longestCommonSubsequence(new CharSequenceAsList( a ), new CharSequenceAsList( b ));
         final StringBuilder sb = new StringBuilder();
@@ -637,17 +644,16 @@ public class ListUtils {
      * <p>
      * Adapted from http://code.google.com/p/guava-libraries/
      *
-     * @param <T> the element type
+     * @param <T>  the element type
      * @param list  the list to return consecutive sublists of
      * @param size  the desired size of each sublist (the last may be smaller)
      * @return a list of consecutive sublists
-     * @throws NullPointerException if list is null
-     * @throws IllegalArgumentException if size is not strictly positive
+     * @throws IllegalArgumentException if list is {@code null} or size is not strictly positive
      * @since 4.0
      */
     public static <T> List<List<T>> partition(final List<T> list, final int size) {
         if (list == null) {
-            throw new NullPointerException("List must not be null");
+            throw new IllegalArgumentException("List must not be null");
         }
         if (size <= 0) {
             throw new IllegalArgumentException("Size must be greater than 0");
diff --git a/src/main/java/org/apache/commons/collections4/MapUtils.java b/src/main/java/org/apache/commons/collections4/MapUtils.java
index b6786bbc..283e07ef 100644
--- a/src/main/java/org/apache/commons/collections4/MapUtils.java
+++ b/src/main/java/org/apache/commons/collections4/MapUtils.java
@@ -1262,7 +1262,7 @@ public class MapUtils {
      * @param <V>  the value type
      * @param map  the map to make unmodifiable, must not be null
      * @return an unmodifiable map backed by the given map
-     * @throws NullPointerException  if the map is null
+     * @throws IllegalArgumentException  if the map is null
      */
     public static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {
         return UnmodifiableMap.unmodifiableMap(map);
@@ -1283,7 +1283,7 @@ public class MapUtils {
      * @param keyPred  the predicate for keys, null means no check
      * @param valuePred  the predicate for values, null means no check
      * @return a predicated map backed by the given map
-     * @throws NullPointerException  if the Map is null
+     * @throws IllegalArgumentException  if the Map is null
      */
     public static <K, V> IterableMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPred,
                                                          final Predicate<? super V> valuePred) {
@@ -1311,7 +1311,7 @@ public class MapUtils {
      * @param keyTransformer  the transformer for the map keys, null means no transformation
      * @param valueTransformer  the transformer for the map values, null means no transformation
      * @return a transformed map backed by the given map
-     * @throws NullPointerException  if the Map is null
+     * @throws IllegalArgumentException  if the Map is null
      */
     public static <K, V> IterableMap<K, V> transformedMap(final Map<K, V> map,
             final Transformer<? super K, ? extends K> keyTransformer,
@@ -1329,7 +1329,7 @@ public class MapUtils {
      * @param <V>  the value type
      * @param map  the map whose size to fix, must not be null
      * @return a fixed-size map backed by that map
-     * @throws NullPointerException  if the Map is null
+     * @throws IllegalArgumentException  if the Map is null
      */
     public static <K, V> IterableMap<K, V> fixedSizeMap(final Map<K, V> map) {
         return FixedSizeMap.fixedSizeMap(map);
@@ -1363,7 +1363,7 @@ public class MapUtils {
      * @param map  the map to make lazy, must not be null
      * @param factory  the factory for creating new objects, must not be null
      * @return a lazy map backed by the given map
-     * @throws NullPointerException  if the Map or Factory is null
+     * @throws IllegalArgumentException  if the Map or Factory is null
      */
     public static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {
         return LazyMap.lazyMap(map, factory);
@@ -1404,7 +1404,7 @@ public class MapUtils {
      * @param map  the map to make lazy, must not be null
      * @param transformerFactory  the factory for creating new objects, must not be null
      * @return a lazy map backed by the given map
-     * @throws NullPointerException  if the Map or Transformer is null
+     * @throws IllegalArgumentException  if the Map or Transformer is null
      */
     public static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map,
             final Transformer<? super K, ? extends V> transformerFactory) {
@@ -1422,7 +1422,7 @@ public class MapUtils {
      * @param <V>  the value type
      * @param map  the map to order, must not be null
      * @return an ordered map backed by the given map
-     * @throws NullPointerException  if the Map is null
+     * @throws IllegalArgumentException  if the Map is null
      */
     public static <K, V> OrderedMap<K, V> orderedMap(final Map<K, V> map) {
         return ListOrderedMap.listOrderedMap(map);
@@ -1512,7 +1512,7 @@ public class MapUtils {
      * @param <V>  the value type
      * @param map  the map to synchronize, must not be null
      * @return a synchronized map backed by the given map
-     * @throws NullPointerException  if the map is null
+     * @throws IllegalArgumentException  if the map is null
      */
     public static <K, V> SortedMap<K, V> synchronizedSortedMap(final SortedMap<K, V> map) {
         return Collections.synchronizedSortedMap(map);
@@ -1527,7 +1527,7 @@ public class MapUtils {
      * @param <V>  the value type
      * @param map  the sorted map to make unmodifiable, must not be null
      * @return an unmodifiable map backed by the given map
-     * @throws NullPointerException  if the map is null
+     * @throws IllegalArgumentException  if the map is null
      */
     public static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {
         return UnmodifiableSortedMap.unmodifiableSortedMap(map);
@@ -1548,7 +1548,7 @@ public class MapUtils {
      * @param keyPred  the predicate for keys, null means no check
      * @param valuePred  the predicate for values, null means no check
      * @return a predicated map backed by the given map
-     * @throws NullPointerException  if the SortedMap is null
+     * @throws IllegalArgumentException  if the SortedMap is null
      */
     public static <K, V> SortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map,
             final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {
@@ -1576,7 +1576,7 @@ public class MapUtils {
      * @param keyTransformer  the transformer for the map keys, null means no transformation
      * @param valueTransformer  the transformer for the map values, null means no transformation
      * @return a transformed map backed by the given map
-     * @throws NullPointerException  if the SortedMap is null
+     * @throws IllegalArgumentException  if the SortedMap is null
      */
     public static <K, V> SortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map,
             final Transformer<? super K, ? extends K> keyTransformer,
@@ -1594,7 +1594,7 @@ public class MapUtils {
      * @param <V>  the value type
      * @param map  the map whose size to fix, must not be null
      * @return a fixed-size map backed by that map
-     * @throws NullPointerException  if the SortedMap is null
+     * @throws IllegalArgumentException  if the SortedMap is null
      */
     public static <K, V> SortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {
         return FixedSizeSortedMap.fixedSizeSortedMap(map);
@@ -1629,7 +1629,7 @@ public class MapUtils {
      * @param map  the map to make lazy, must not be null
      * @param factory  the factory for creating new objects, must not be null
      * @return a lazy map backed by the given map
-     * @throws NullPointerException  if the SortedMap or Factory is null
+     * @throws IllegalArgumentException  if the SortedMap or Factory is null
      */
     public static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {
         return LazySortedMap.lazySortedMap(map, factory);
@@ -1670,7 +1670,7 @@ public class MapUtils {
      * @param map  the map to make lazy, must not be null
      * @param transformerFactory  the factory for creating new objects, must not be null
      * @return a lazy map backed by the given map
-     * @throws NullPointerException  if the Map or Transformer is null
+     * @throws IllegalArgumentException  if the Map or Transformer is null
      */
     public static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,
             final Transformer<? super K, ? extends V> transformerFactory) {
@@ -1762,12 +1762,11 @@ public class MapUtils {
      * @param <V>  the value type
      * @param map to wrap if necessary.
      * @return IterableMap<K, V>
-     * @throws NullPointerException if map is null
      * @since 4.0
      */
     public static <K, V> IterableMap<K, V> iterableMap(final Map<K, V> map) {
         if (map == null) {
-            throw new NullPointerException("Map must not be null");
+            throw new IllegalArgumentException("Map must not be null");
         }
         return map instanceof IterableMap ? (IterableMap<K, V>) map : new AbstractMapDecorator<K, V>(map) {};
     }
@@ -1779,12 +1778,11 @@ public class MapUtils {
      * @param <V>  the value type
      * @param sortedMap to wrap if necessary
      * @return {@link IterableSortedMap}<K, V>
-     * @throws NullPointerException if sortedMap is null
      * @since 4.0
      */
     public static <K, V> IterableSortedMap<K, V> iterableSortedMap(final SortedMap<K, V> sortedMap) {
         if (sortedMap == null) {
-            throw new NullPointerException("Map must not be null");
+            throw new IllegalArgumentException("Map must not be null");
         }
         return sortedMap instanceof IterableSortedMap ? (IterableSortedMap<K, V>) sortedMap :
                                                         new AbstractSortedMapDecorator<K, V>(sortedMap) {};
diff --git a/src/main/java/org/apache/commons/collections4/PredicateUtils.java b/src/main/java/org/apache/commons/collections4/PredicateUtils.java
index ac2d3313..bd0d5161 100644
--- a/src/main/java/org/apache/commons/collections4/PredicateUtils.java
+++ b/src/main/java/org/apache/commons/collections4/PredicateUtils.java
@@ -168,7 +168,7 @@ public class PredicateUtils {
      *
      * @param type  the type to check for, may not be null
      * @return the predicate
-     * @throws NullPointerException if the class is null
+     * @throws IllegalArgumentException if the class is null
      * @see InstanceofPredicate
      */
     public static Predicate<Object> instanceofPredicate(final Class<?> type) {
@@ -204,7 +204,7 @@ public class PredicateUtils {
      * @param <T>  the type that the predicate queries
      * @param methodName  the method name to call on the input object, may not be null
      * @return the predicate
-     * @throws NullPointerException if the methodName is null.
+     * @throws IllegalArgumentException if the methodName is null.
      * @see InvokerTransformer
      * @see TransformerPredicate
      */
@@ -228,7 +228,7 @@ public class PredicateUtils {
      * @param paramTypes  the parameter types
      * @param args  the arguments
      * @return the predicate
-     * @throws NullPointerException if the method name is null
+     * @throws IllegalArgumentException if the method name is null
      * @throws IllegalArgumentException if the paramTypes and args don't match
      * @see InvokerTransformer
      * @see TransformerPredicate
@@ -250,7 +250,7 @@ public class PredicateUtils {
      * @param predicate1  the first predicate, may not be null
      * @param predicate2  the second predicate, may not be null
      * @return the <code>and</code> predicate
-     * @throws NullPointerException if either predicate is null
+     * @throws IllegalArgumentException if either predicate is null
      * @see AndPredicate
      */
     public static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1,
@@ -266,8 +266,8 @@ public class PredicateUtils {
      * @param <T>  the type that the predicate queries
      * @param predicates  an array of predicates to check, may not be null
      * @return the <code>all</code> predicate
-     * @throws NullPointerException if the predicates array is null
-     * @throws NullPointerException if any predicate in the array is null
+     * @throws IllegalArgumentException if the predicates array is null
+     * @throws IllegalArgumentException if any predicate in the array is null
      * @see AllPredicate
      */
     public static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {
@@ -282,8 +282,8 @@ public class PredicateUtils {
      * @param <T>  the type that the predicate queries
      * @param predicates  a collection of predicates to check, may not be null
      * @return the <code>all</code> predicate
-     * @throws NullPointerException if the predicates collection is null
-     * @throws NullPointerException if any predicate in the collection is null
+     * @throws IllegalArgumentException if the predicates collection is null
+     * @throws IllegalArgumentException if any predicate in the collection is null
      * @see AllPredicate
      */
     public static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {
@@ -298,7 +298,7 @@ public class PredicateUtils {
      * @param predicate1  the first predicate, may not be null
      * @param predicate2  the second predicate, may not be null
      * @return the <code>or</code> predicate
-     * @throws NullPointerException if either predicate is null
+     * @throws IllegalArgumentException if either predicate is null
      * @see OrPredicate
      */
     public static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1,
@@ -314,8 +314,8 @@ public class PredicateUtils {
      * @param <T>  the type that the predicate queries
      * @param predicates  an array of predicates to check, may not be null
      * @return the <code>any</code> predicate
-     * @throws NullPointerException if the predicates array is null
-     * @throws NullPointerException if any predicate in the array is null
+     * @throws IllegalArgumentException if the predicates array is null
+     * @throws IllegalArgumentException if any predicate in the array is null
      * @see AnyPredicate
      */
     public static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {
@@ -330,8 +330,8 @@ public class PredicateUtils {
      * @param <T>  the type that the predicate queries
      * @param predicates  a collection of predicates to check, may not be null
      * @return the <code>any</code> predicate
-     * @throws NullPointerException if the predicates collection is null
-     * @throws NullPointerException if any predicate in the collection is null
+     * @throws IllegalArgumentException if the predicates collection is null
+     * @throws IllegalArgumentException if any predicate in the collection is null
      * @see AnyPredicate
      */
     public static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {
@@ -346,7 +346,7 @@ public class PredicateUtils {
      * @param predicate1  the first predicate, may not be null
      * @param predicate2  the second predicate, may not be null
      * @return the <code>either</code> predicate
-     * @throws NullPointerException if either predicate is null
+     * @throws IllegalArgumentException if either predicate is null
      * @see OnePredicate
      */
     public static <T> Predicate<T> eitherPredicate(final Predicate<? super T> predicate1,
@@ -364,8 +364,8 @@ public class PredicateUtils {
      * @param <T>  the type that the predicate queries
      * @param predicates  an array of predicates to check, may not be null
      * @return the <code>one</code> predicate
-     * @throws NullPointerException if the predicates array is null
-     * @throws NullPointerException if any predicate in the array is null
+     * @throws IllegalArgumentException if the predicates array is null
+     * @throws IllegalArgumentException if any predicate in the array is null
      * @see OnePredicate
      */
     public static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {
@@ -380,8 +380,8 @@ public class PredicateUtils {
      * @param <T>  the type that the predicate queries
      * @param predicates  a collection of predicates to check, may not be null
      * @return the <code>one</code> predicate
-     * @throws NullPointerException if the predicates collection is null
-     * @throws NullPointerException if any predicate in the collection is null
+     * @throws IllegalArgumentException if the predicates collection is null
+     * @throws IllegalArgumentException if any predicate in the collection is null
      * @see OnePredicate
      */
     public static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {
@@ -396,7 +396,7 @@ public class PredicateUtils {
      * @param predicate1  the first predicate, may not be null
      * @param predicate2  the second predicate, may not be null
      * @return the <code>neither</code> predicate
-     * @throws NullPointerException if either predicate is null
+     * @throws IllegalArgumentException if either predicate is null
      * @see NonePredicate
      */
     public static <T> Predicate<T> neitherPredicate(final Predicate<? super T> predicate1,
@@ -414,8 +414,8 @@ public class PredicateUtils {
      * @param <T>  the type that the predicate queries
      * @param predicates  an array of predicates to check, may not be null
      * @return the <code>none</code> predicate
-     * @throws NullPointerException if the predicates array is null
-     * @throws NullPointerException if any predicate in the array is null
+     * @throws IllegalArgumentException if the predicates array is null
+     * @throws IllegalArgumentException if any predicate in the array is null
      * @see NonePredicate
      */
     public static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {
@@ -430,8 +430,8 @@ public class PredicateUtils {
      * @param <T>  the type that the predicate queries
      * @param predicates  a collection of predicates to check, may not be null
      * @return the <code>none</code> predicate
-     * @throws NullPointerException if the predicates collection is null
-     * @throws NullPointerException if any predicate in the collection is null
+     * @throws IllegalArgumentException if the predicates collection is null
+     * @throws IllegalArgumentException if any predicate in the collection is null
      * @see NonePredicate
      */
     public static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {
@@ -445,7 +445,7 @@ public class PredicateUtils {
      * @param <T>  the type that the predicate queries
      * @param predicate  the predicate to not
      * @return the <code>not</code> predicate
-     * @throws NullPointerException if the predicate is null
+     * @throws IllegalArgumentException if the predicate is null
      * @see NotPredicate
      */
     public static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {
@@ -463,7 +463,7 @@ public class PredicateUtils {
      * @param <T>  the type that the predicate queries
      * @param transformer  the transformer to wrap, may not be null
      * @return the transformer wrapping predicate
-     * @throws NullPointerException if the transformer is null
+     * @throws IllegalArgumentException if the transformer is null
      * @see TransformerPredicate
      */
     public static <T> Predicate<T> asPredicate(final Transformer<? super T, Boolean> transformer) {
@@ -481,7 +481,7 @@ public class PredicateUtils {
      * @param <T>  the type that the predicate queries
      * @param predicate  the predicate to wrap, may not be null
      * @return the predicate
-     * @throws NullPointerException if the predicate is null.
+     * @throws IllegalArgumentException if the predicate is null.
      * @see NullIsExceptionPredicate
      */
     public static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate){
@@ -496,7 +496,7 @@ public class PredicateUtils {
      * @param <T>  the type that the predicate queries
      * @param predicate  the predicate to wrap, may not be null
      * @return the predicate
-     * @throws NullPointerException if the predicate is null.
+     * @throws IllegalArgumentException if the predicate is null.
      * @see NullIsFalsePredicate
      */
     public static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate){
@@ -511,7 +511,7 @@ public class PredicateUtils {
      * @param <T>  the type that the predicate queries
      * @param predicate  the predicate to wrap, may not be null
      * @return the predicate
-     * @throws NullPointerException if the predicate is null.
+     * @throws IllegalArgumentException if the predicate is null.
      * @see NullIsTruePredicate
      */
     public static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate){
@@ -528,7 +528,7 @@ public class PredicateUtils {
      * @param transformer  the transformer to call first
      * @param predicate  the predicate to call with the result of the transform
      * @return the predicate
-     * @throws NullPointerException if the transformer or the predicate is null
+     * @throws IllegalArgumentException if the transformer or the predicate is null
      * @see TransformedPredicate
      * @since 3.1
      */
diff --git a/src/main/java/org/apache/commons/collections4/QueueUtils.java b/src/main/java/org/apache/commons/collections4/QueueUtils.java
index d3177085..3d6d540f 100644
--- a/src/main/java/org/apache/commons/collections4/QueueUtils.java
+++ b/src/main/java/org/apache/commons/collections4/QueueUtils.java
@@ -50,7 +50,7 @@ public class QueueUtils {
      * @param <E> the type of the elements in the queue
      * @param queue  the queue to make unmodifiable, must not be null
      * @return an unmodifiable queue backed by that queue
-     * @throws NullPointerException if the queue is null
+     * @throws IllegalArgumentException  if the Queue is null
      */
     public static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {
         return UnmodifiableQueue.unmodifiableQueue(queue);
@@ -68,7 +68,7 @@ public class QueueUtils {
      * @param queue  the queue to predicate, must not be null
      * @param predicate  the predicate used to evaluate new elements, must not be null
      * @return a predicated queue
-     * @throws NullPointerException if the queue or predicate is null
+     * @throws IllegalArgumentException  if the Queue or Predicate is null
      */
     public static <E> Queue<E> predicatedQueue(final Queue<E> queue, final Predicate<? super E> predicate) {
         return PredicatedQueue.predicatedQueue(queue, predicate);
@@ -88,7 +88,7 @@ public class QueueUtils {
      * @param queue  the queue to predicate, must not be null
      * @param transformer  the transformer for the queue, must not be null
      * @return a transformed queue backed by the given queue
-     * @throws NullPointerException if the queue or transformer is null
+     * @throws IllegalArgumentException  if the Queue or Transformer is null
      */
     public static <E> Queue<E> transformingQueue(final Queue<E> queue,
                                                  final Transformer<? super E, ? extends E> transformer) {
diff --git a/src/main/java/org/apache/commons/collections4/SetUtils.java b/src/main/java/org/apache/commons/collections4/SetUtils.java
index 839c9425..d057c79b 100644
--- a/src/main/java/org/apache/commons/collections4/SetUtils.java
+++ b/src/main/java/org/apache/commons/collections4/SetUtils.java
@@ -202,7 +202,7 @@ public class SetUtils {
      * @param <E> the element type
      * @param set  the set to synchronize, must not be null
      * @return a synchronized set backed by the given set
-     * @throws NullPointerException if the set is null
+     * @throws IllegalArgumentException  if the set is null
      */
     public static <E> Set<E> synchronizedSet(final Set<E> set) {
         return Collections.synchronizedSet(set);
@@ -216,7 +216,7 @@ public class SetUtils {
      * @param <E> the element type
      * @param set  the set to make unmodifiable, must not be null
      * @return an unmodifiable set backed by the given set
-     * @throws NullPointerException if the set is null
+     * @throws IllegalArgumentException  if the set is null
      */
     public static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {
         return UnmodifiableSet.unmodifiableSet(set);
@@ -234,7 +234,7 @@ public class SetUtils {
      * @param set  the set to predicate, must not be null
      * @param predicate  the predicate for the set, must not be null
      * @return a predicated set backed by the given set
-     * @throws NullPointerException if the set or predicate is null
+     * @throws IllegalArgumentException  if the Set or Predicate is null
      */
     public static <E> Set<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {
         return PredicatedSet.predicatedSet(set, predicate);
@@ -254,7 +254,7 @@ public class SetUtils {
      * @param set  the set to transform, must not be null
      * @param transformer  the transformer for the set, must not be null
      * @return a transformed set backed by the given set
-     * @throws NullPointerException if the set or transformer is null
+     * @throws IllegalArgumentException  if the Set or Transformer is null
      */
     public static <E> Set<E> transformedSet(final Set<E> set,
                                             final Transformer<? super E, ? extends E> transformer) {
@@ -271,7 +271,7 @@ public class SetUtils {
      * @param <E> the element type
      * @param set  the set to order, must not be null
      * @return an ordered set backed by the given set
-     * @throws NullPointerException if the set is null
+     * @throws IllegalArgumentException  if the Set is null
      */
     public static <E> Set<E> orderedSet(final Set<E> set) {
         return ListOrderedSet.listOrderedSet(set);
@@ -300,7 +300,7 @@ public class SetUtils {
      * @param <E> the element type
      * @param set  the sorted set to synchronize, must not be null
      * @return a synchronized set backed by the given set
-     * @throws NullPointerException if the set is null
+     * @throws IllegalArgumentException  if the set is null
      */
     public static <E> SortedSet<E> synchronizedSortedSet(final SortedSet<E> set) {
         return Collections.synchronizedSortedSet(set);
@@ -314,7 +314,7 @@ public class SetUtils {
      * @param <E> the element type
      * @param set  the sorted set to make unmodifiable, must not be null
      * @return an unmodifiable set backed by the given set
-     * @throws NullPointerException if the set is null
+     * @throws IllegalArgumentException  if the set is null
      */
     public static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {
         return UnmodifiableSortedSet.unmodifiableSortedSet(set);
@@ -332,7 +332,7 @@ public class SetUtils {
      * @param set  the sorted set to predicate, must not be null
      * @param predicate  the predicate for the sorted set, must not be null
      * @return a predicated sorted set backed by the given sorted set
-     * @throws NullPointerException if the set or predicate is null
+     * @throws IllegalArgumentException  if the Set or Predicate is null
      */
     public static <E> SortedSet<E> predicatedSortedSet(final SortedSet<E> set,
                                                        final Predicate<? super E> predicate) {
@@ -353,7 +353,7 @@ public class SetUtils {
      * @param set  the set to transform, must not be null
      * @param transformer  the transformer for the set, must not be null
      * @return a transformed set backed by the given set
-     * @throws NullPointerException if the set or transformer is null
+     * @throws IllegalArgumentException  if the Set or Transformer is null
      */
     public static <E> SortedSet<E> transformedSortedSet(final SortedSet<E> set,
                                                         final Transformer<? super E, ? extends E> transformer) {
@@ -370,7 +370,7 @@ public class SetUtils {
      * @param <E> the element type
      * @param set  the navigable set to make unmodifiable, must not be null
      * @return an unmodifiable set backed by the given set
-     * @throws NullPointerException if the set is null
+     * @throws IllegalArgumentException  if the set is null
      * @since 4.1
      */
     public static <E> SortedSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {
@@ -389,7 +389,7 @@ public class SetUtils {
      * @param set  the navigable set to predicate, must not be null
      * @param predicate  the predicate for the navigable set, must not be null
      * @return a predicated navigable set backed by the given navigable set
-     * @throws NullPointerException if the set or predicate is null
+     * @throws IllegalArgumentException  if the Set or Predicate is null
      * @since 4.1
      */
     public static <E> SortedSet<E> predicatedNavigableSet(final NavigableSet<E> set,
@@ -411,7 +411,7 @@ public class SetUtils {
      * @param set  the navigable set to transform, must not be null
      * @param transformer  the transformer for the set, must not be null
      * @return a transformed set backed by the given set
-     * @throws NullPointerException if the set or transformer is null
+     * @throws IllegalArgumentException  if the Set or Transformer is null
      * @since 4.1
      */
     public static <E> SortedSet<E> transformedNavigableSet(final NavigableSet<E> set,
diff --git a/src/main/java/org/apache/commons/collections4/SplitMapUtils.java b/src/main/java/org/apache/commons/collections4/SplitMapUtils.java
index 7b27ed63..c4af3b19 100644
--- a/src/main/java/org/apache/commons/collections4/SplitMapUtils.java
+++ b/src/main/java/org/apache/commons/collections4/SplitMapUtils.java
@@ -20,11 +20,11 @@ import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
 
+import org.apache.commons.collections4.set.UnmodifiableSet;
 import org.apache.commons.collections4.collection.UnmodifiableCollection;
 import org.apache.commons.collections4.iterators.UnmodifiableMapIterator;
 import org.apache.commons.collections4.map.EntrySetToMapIteratorAdapter;
 import org.apache.commons.collections4.map.UnmodifiableEntrySet;
-import org.apache.commons.collections4.set.UnmodifiableSet;
 
 /**
  * Utilities for working with "split maps:" objects that implement {@link Put}
@@ -205,17 +205,15 @@ public class SplitMapUtils {
      * @param <V> the value type
      * @param get to wrap, must not be null
      * @return {@link IterableMap}
-     * @throws NullPointerException if the argument is null
      */
     @SuppressWarnings("unchecked")
     public static <K, V> IterableMap<K, V> readableMap(final Get<K, V> get) {
         if (get == null) {
-            throw new NullPointerException("Get must not be null");
+            throw new IllegalArgumentException("Get must not be null");
         }
         if (get instanceof Map) {
-            return get instanceof IterableMap ?
-                    ((IterableMap<K, V>) get) :
-                    MapUtils.iterableMap((Map<K, V>) get);
+            return get instanceof IterableMap ? ((IterableMap<K, V>) get) : MapUtils
+                    .iterableMap((Map<K, V>) get);
         }
         return new WrappedGet<K, V>(get);
     }
@@ -231,12 +229,11 @@ public class SplitMapUtils {
      * @param <V> the element type
      * @param put to wrap, must not be null
      * @return {@link Map}
-     * @throws NullPointerException if the argument is null
      */
     @SuppressWarnings("unchecked")
     public static <K, V> Map<K, V> writableMap(final Put<K, V> put) {
         if (put == null) {
-            throw new NullPointerException("Put must not be null");
+            throw new IllegalArgumentException("Put must not be null");
         }
         if (put instanceof Map) {
             return (Map<K, V>) put;
diff --git a/src/main/java/org/apache/commons/collections4/TransformerUtils.java b/src/main/java/org/apache/commons/collections4/TransformerUtils.java
index 05a94f5e..45000b53 100644
--- a/src/main/java/org/apache/commons/collections4/TransformerUtils.java
+++ b/src/main/java/org/apache/commons/collections4/TransformerUtils.java
@@ -144,7 +144,7 @@ public class TransformerUtils {
      * @param <T>  the input/output type
      * @param closure  the closure to run each time in the transformer, not null
      * @return the transformer
-     * @throws NullPointerException if the closure is null
+     * @throws IllegalArgumentException if the closure is null
      * @see ClosureTransformer
      */
     public static <T> Transformer<T, T> asTransformer(final Closure<? super T> closure) {
@@ -158,7 +158,7 @@ public class TransformerUtils {
      * @param <T>  the input type
      * @param predicate  the predicate to run each time in the transformer, not null
      * @return the transformer
-     * @throws NullPointerException if the predicate is null
+     * @throws IllegalArgumentException if the predicate is null
      * @see PredicateTransformer
      */
     public static <T> Transformer<T, Boolean> asTransformer(final Predicate<? super T> predicate) {
@@ -173,7 +173,7 @@ public class TransformerUtils {
      * @param <O>  the output type
      * @param factory  the factory to run each time in the transformer, not null
      * @return the transformer
-     * @throws NullPointerException if the factory is null
+     * @throws IllegalArgumentException if the factory is null
      * @see FactoryTransformer
      */
     public static <I, O> Transformer<I, O> asTransformer(final Factory<? extends O> factory) {
@@ -187,7 +187,7 @@ public class TransformerUtils {
      * @param <T>  the input/output type
      * @param transformers  an array of transformers to chain
      * @return the transformer
-     * @throws NullPointerException if the transformers array or any of the transformers is null
+     * @throws IllegalArgumentException if the transformers array or any of the transformers is null
      * @see ChainedTransformer
      */
     public static <T> Transformer<T, T> chainedTransformer(
@@ -203,7 +203,7 @@ public class TransformerUtils {
      * @param <T>  the input/output type
      * @param transformers  a collection of transformers to chain
      * @return the transformer
-     * @throws NullPointerException if the transformers collection or any of the transformers is null
+     * @throws IllegalArgumentException if the transformers collection or any of the transformers is null
      * @see ChainedTransformer
      */
     public static <T> Transformer<T, T> chainedTransformer(
@@ -219,7 +219,7 @@ public class TransformerUtils {
      * @param predicate  the predicate to switch on
      * @param trueTransformer  the transformer called if the predicate is true
      * @return the transformer
-     * @throws NullPointerException if either the predicate or transformer is null
+     * @throws IllegalArgumentException if either the predicate or transformer is null
      * @see IfTransformer
      * @since 4.1
      */
@@ -238,7 +238,7 @@ public class TransformerUtils {
      * @param trueTransformer  the transformer called if the predicate is true
      * @param falseTransformer  the transformer called if the predicate is false
      * @return the transformer
-     * @throws NullPointerException if either the predicate or transformer is null
+     * @throws IllegalArgumentException if either the predicate or transformer is null
      * @see IfTransformer
      * @since 4.1
      */
@@ -258,7 +258,7 @@ public class TransformerUtils {
      * @param trueTransformer  the transformer called if the predicate is true
      * @param falseTransformer  the transformer called if the predicate is false
      * @return the transformer
-     * @throws NullPointerException if either the predicate or transformer is null
+     * @throws IllegalArgumentException if either the predicate or transformer is null
      * @see SwitchTransformer
      * @deprecated as of 4.1, use {@link #ifTransformer(Predicate, Transformer, Transformer))
      */
@@ -282,9 +282,9 @@ public class TransformerUtils {
      * @param predicates  an array of predicates to check
      * @param transformers  an array of transformers to call
      * @return the transformer
-     * @throws NullPointerException if the either array is null
-     * @throws NullPointerException if any element in the arrays is null
-     * @throws IllegalArgumentException if the arrays have different sizes
+     * @throws IllegalArgumentException if the either array is null or empty
+     * @throws IllegalArgumentException if any element in the arrays is null
+     * @throws IllegalArgumentException if the arrays are different sizes
      * @see SwitchTransformer
      */
     public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates,
@@ -305,9 +305,9 @@ public class TransformerUtils {
      * @param transformers  an array of transformers to call
      * @param defaultTransformer  the default to call if no predicate matches, null means return null
      * @return the transformer
-     * @throws NullPointerException if the either array is null
-     * @throws NullPointerException if any element in the arrays is null
-     * @throws IllegalArgumentException if the arrays have different sizes
+     * @throws IllegalArgumentException if the either array is null or empty
+     * @throws IllegalArgumentException if any element in the arrays is null
+     * @throws IllegalArgumentException if the arrays are different sizes
      * @see SwitchTransformer
      */
     public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates,
@@ -332,8 +332,8 @@ public class TransformerUtils {
      * @param <O>  the output type
      * @param predicatesAndTransformers  a map of predicates to transformers
      * @return the transformer
-     * @throws NullPointerException if the map is null
-     * @throws NullPointerException if any transformer in the map is null
+     * @throws IllegalArgumentException if the map is null or empty
+     * @throws IllegalArgumentException if any transformer in the map is null
      * @throws ClassCastException  if the map elements are of the wrong type
      * @see SwitchTransformer
      */
@@ -355,8 +355,8 @@ public class TransformerUtils {
      * @param <O>  the output type
      * @param objectsAndTransformers  a map of objects to transformers
      * @return the transformer
-     * @throws NullPointerException if the map is null
-     * @throws NullPointerException if any transformer in the map is null
+     * @throws IllegalArgumentException if the map is null or empty
+     * @throws IllegalArgumentException if any transformer in the map is null
      * @see SwitchTransformer
      */
     @SuppressWarnings("unchecked")
@@ -364,7 +364,7 @@ public class TransformerUtils {
             final Map<I, Transformer<I, O>> objectsAndTransformers) {
 
         if (objectsAndTransformers == null) {
-            throw new NullPointerException("The object and transformer map must not be null");
+            throw new IllegalArgumentException("The object and transformer map must not be null");
         }
         final Transformer<? super I, ? extends O> def = objectsAndTransformers.remove(null);
         final int size = objectsAndTransformers.size();
@@ -434,7 +434,7 @@ public class TransformerUtils {
      * @param <O>  the output type
      * @param methodName  the method name to call on the input object, may not be null
      * @return the transformer
-     * @throws NullPointerException if the methodName is null.
+     * @throws IllegalArgumentException if the methodName is null.
      * @see InvokerTransformer
      */
     public static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {
@@ -452,8 +452,7 @@ public class TransformerUtils {
      * @param paramTypes  the parameter types
      * @param args  the arguments
      * @return the transformer
-     * @throws NullPointerException if the method name is null
-     * @throws IllegalArgumentException if the paramTypes and args don't match
+     * @throws IllegalArgumentException if the method name is null or the paramTypes and args don't match
      * @see InvokerTransformer
      */
     public static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes,
diff --git a/src/main/java/org/apache/commons/collections4/TrieUtils.java b/src/main/java/org/apache/commons/collections4/TrieUtils.java
index 6401844b..4380cd36 100644
--- a/src/main/java/org/apache/commons/collections4/TrieUtils.java
+++ b/src/main/java/org/apache/commons/collections4/TrieUtils.java
@@ -38,7 +38,6 @@ public class TrieUtils {
      * @param <V>  the value type
      * @param trie  the trie to make unmodifiable, must not be null
      * @return an unmodifiable trie backed by the given trie
-     * @throws NullPointerException if trie is null
      *
      * @see java.util.Collections#unmodifiableMap(java.util.Map)
      */
diff --git a/src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java b/src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java
index c38a77e3..aa7d08c2 100644
--- a/src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java
@@ -47,7 +47,7 @@ public abstract class AbstractBagDecorator<E>
      * Constructor that wraps (not copies).
      *
      * @param bag  the bag to decorate, must not be null
-     * @throws NullPointerException if bag is null
+     * @throws IllegalArgumentException if list is null
      */
     protected AbstractBagDecorator(final Bag<E> bag) {
         super(bag);
diff --git a/src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java b/src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java
index 7b016031..e6ecc77a 100644
--- a/src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java
@@ -46,7 +46,7 @@ public abstract class AbstractSortedBagDecorator<E>
      * Constructor that wraps (not copies).
      *
      * @param bag  the bag to decorate, must not be null
-     * @throws NullPointerException if bag is null
+     * @throws IllegalArgumentException if list is null
      */
     protected AbstractSortedBagDecorator(final SortedBag<E> bag) {
         super(bag);
diff --git a/src/main/java/org/apache/commons/collections4/bag/CollectionBag.java b/src/main/java/org/apache/commons/collections4/bag/CollectionBag.java
index ceb7c516..0cc15d89 100644
--- a/src/main/java/org/apache/commons/collections4/bag/CollectionBag.java
+++ b/src/main/java/org/apache/commons/collections4/bag/CollectionBag.java
@@ -49,7 +49,7 @@ public final class CollectionBag<E> extends AbstractBagDecorator<E> {
      * @param <E> the type of the elements in the bag
      * @param bag  the bag to decorate, must not be null
      * @return a Bag that complies to the Collection contract
-     * @throws NullPointerException if bag is null
+     * @throws IllegalArgumentException if bag is null
      */
     public static <E> Bag<E> collectionBag(final Bag<E> bag) {
         return new CollectionBag<E>(bag);
@@ -60,7 +60,7 @@ public final class CollectionBag<E> extends AbstractBagDecorator<E> {
      * Constructor that wraps (not copies).
      *
      * @param bag  the bag to decorate, must not be null
-     * @throws NullPointerException if bag is null
+     * @throws IllegalArgumentException if bag is null
      */
     public CollectionBag(final Bag<E> bag) {
         super(bag);
diff --git a/src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java b/src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java
index 1b2c8ff6..cf17cef1 100644
--- a/src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java
+++ b/src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java
@@ -41,7 +41,7 @@ public final class CollectionSortedBag<E> extends AbstractSortedBagDecorator<E>
      * @param <E> the type of the elements in the bag
      * @param bag  the sorted bag to decorate, must not be null
      * @return a SortedBag that complies to the Collection contract
-     * @throws NullPointerException if bag is null
+     * @throws IllegalArgumentException if bag is null
      */
     public static <E> SortedBag<E> collectionSortedBag(final SortedBag<E> bag) {
         return new CollectionSortedBag<E>(bag);
@@ -52,7 +52,7 @@ public final class CollectionSortedBag<E> extends AbstractSortedBagDecorator<E>
      * Constructor that wraps (not copies).
      *
      * @param bag  the sorted bag to decorate, must not be null
-     * @throws NullPointerException if bag is null
+     * @throws IllegalArgumentException if bag is null
      */
     public CollectionSortedBag(final SortedBag<E> bag) {
         super(bag);
diff --git a/src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java b/src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java
index 46501fb7..7975c1d2 100644
--- a/src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java
+++ b/src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java
@@ -55,7 +55,7 @@ public class PredicatedBag<E> extends PredicatedCollection<E> implements Bag<E>
      * @param bag  the bag to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
      * @return a new predicated Bag
-     * @throws NullPointerException if bag or predicate is null
+     * @throws IllegalArgumentException if bag or predicate is null
      * @throws IllegalArgumentException if the bag contains invalid elements
      * @since 4.0
      */
@@ -72,7 +72,7 @@ public class PredicatedBag<E> extends PredicatedCollection<E> implements Bag<E>
      *
      * @param bag  the bag to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
-     * @throws NullPointerException if bag or predicate is null
+     * @throws IllegalArgumentException if bag or predicate is null
      * @throws IllegalArgumentException if the bag contains invalid elements
      */
     protected PredicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {
diff --git a/src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java b/src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java
index 404ea774..bfd4d7b8 100644
--- a/src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java
+++ b/src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java
@@ -54,7 +54,7 @@ public class PredicatedSortedBag<E> extends PredicatedBag<E> implements SortedBa
      * @param bag  the bag to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
      * @return a new predicated SortedBag
-     * @throws NullPointerException if bag or predicate is null
+     * @throws IllegalArgumentException if bag or predicate is null
      * @throws IllegalArgumentException if the bag contains invalid elements
      * @since 4.0
      */
@@ -71,7 +71,7 @@ public class PredicatedSortedBag<E> extends PredicatedBag<E> implements SortedBa
      *
      * @param bag  the bag to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
-     * @throws NullPointerException if bag or predicate is null
+     * @throws IllegalArgumentException if bag or predicate is null
      * @throws IllegalArgumentException if the bag contains invalid elements
      */
     protected PredicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {
diff --git a/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java b/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java
index 07a7ab9b..26005e6f 100644
--- a/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java
+++ b/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java
@@ -44,7 +44,7 @@ public class SynchronizedBag<E> extends SynchronizedCollection<E> implements Bag
      * @param <E> the type of the elements in the bag
      * @param bag  the bag to decorate, must not be null
      * @return a new synchronized Bag
-     * @throws NullPointerException if bag is null
+     * @throws IllegalArgumentException if bag is null
      * @since 4.0
      */
     public static <E> SynchronizedBag<E> synchronizedBag(final Bag<E> bag) {
@@ -56,7 +56,7 @@ public class SynchronizedBag<E> extends SynchronizedCollection<E> implements Bag
      * Constructor that wraps (not copies).
      *
      * @param bag  the bag to decorate, must not be null
-     * @throws NullPointerException if bag is null
+     * @throws IllegalArgumentException if bag is null
      */
     protected SynchronizedBag(final Bag<E> bag) {
         super(bag);
@@ -67,7 +67,7 @@ public class SynchronizedBag<E> extends SynchronizedCollection<E> implements Bag
      *
      * @param bag  the bag to decorate, must not be null
      * @param lock  the lock to use, must not be null
-     * @throws NullPointerException if bag or lock is null
+     * @throws IllegalArgumentException if bag is null
      */
     protected SynchronizedBag(final Bag<E> bag, final Object lock) {
         super(bag, lock);
diff --git a/src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java b/src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java
index 5f8e803c..41d7e9f0 100644
--- a/src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java
+++ b/src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java
@@ -44,7 +44,7 @@ public class SynchronizedSortedBag<E> extends SynchronizedBag<E> implements Sort
      * @param <E> the type of the elements in the bag
      * @param bag  the bag to decorate, must not be null
      * @return a new synchronized SortedBag
-     * @throws NullPointerException if bag is null
+     * @throws IllegalArgumentException if bag is null
      * @since 4.0
      */
     public static <E> SynchronizedSortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {
@@ -56,7 +56,7 @@ public class SynchronizedSortedBag<E> extends SynchronizedBag<E> implements Sort
      * Constructor that wraps (not copies).
      *
      * @param bag  the bag to decorate, must not be null
-     * @throws NullPointerException if bag is null
+     * @throws IllegalArgumentException if bag is null
      */
     protected SynchronizedSortedBag(final SortedBag<E> bag) {
         super(bag);
@@ -67,7 +67,7 @@ public class SynchronizedSortedBag<E> extends SynchronizedBag<E> implements Sort
      *
      * @param bag  the bag to decorate, must not be null
      * @param lock  the lock to use, must not be null
-     * @throws NullPointerException if bag or lock is null
+     * @throws IllegalArgumentException if bag is null
      */
     protected SynchronizedSortedBag(final Bag<E> bag, final Object lock) {
         super(bag, lock);
diff --git a/src/main/java/org/apache/commons/collections4/bag/TransformedBag.java b/src/main/java/org/apache/commons/collections4/bag/TransformedBag.java
index 1cb603a7..25ff391a 100644
--- a/src/main/java/org/apache/commons/collections4/bag/TransformedBag.java
+++ b/src/main/java/org/apache/commons/collections4/bag/TransformedBag.java
@@ -51,7 +51,7 @@ public class TransformedBag<E> extends TransformedCollection<E> implements Bag<E
      * @param bag  the bag to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed Bag
-     * @throws NullPointerException if bag or transformer is null
+     * @throws IllegalArgumentException if bag or transformer is null
      * @since 4.0
      */
     public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {
@@ -70,12 +70,12 @@ public class TransformedBag<E> extends TransformedCollection<E> implements Bag<E
      * @param bag  the bag to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed Bag
-     * @throws NullPointerException if bag or transformer is null
+     * @throws IllegalArgumentException if bag or transformer is null
      * @since 4.0
      */
     public static <E> Bag<E> transformedBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {
         final TransformedBag<E> decorated = new TransformedBag<E>(bag, transformer);
-        if (bag.size() > 0) {
+        if (transformer != null && bag != null && bag.size() > 0) {
             @SuppressWarnings("unchecked") // Bag is of type E
             final E[] values = (E[]) bag.toArray(); // NOPMD - false positive for generics
             bag.clear();
@@ -95,7 +95,7 @@ public class TransformedBag<E> extends TransformedCollection<E> implements Bag<E
      *
      * @param bag  the bag to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
-     * @throws NullPointerException if bag or transformer is null
+     * @throws IllegalArgumentException if bag or transformer is null
      */
     protected TransformedBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {
         super(bag, transformer);
diff --git a/src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java b/src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java
index 14ee634c..282583cd 100644
--- a/src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java
+++ b/src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java
@@ -49,7 +49,7 @@ public class TransformedSortedBag<E> extends TransformedBag<E> implements Sorted
      * @param bag  the bag to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed SortedBag
-     * @throws NullPointerException if bag or transformer is null
+     * @throws IllegalArgumentException if bag or transformer is null
      * @since 4.0
      */
     public static <E> TransformedSortedBag<E> transformingSortedBag(final SortedBag<E> bag,
@@ -69,14 +69,14 @@ public class TransformedSortedBag<E> extends TransformedBag<E> implements Sorted
      * @param bag  the bag to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed SortedBag
-     * @throws NullPointerException if bag or transformer is null
+     * @throws IllegalArgumentException if bag or transformer is null
      * @since 4.0
      */
     public static <E> TransformedSortedBag<E> transformedSortedBag(final SortedBag<E> bag,
             final Transformer<? super E, ? extends E> transformer) {
 
         final TransformedSortedBag<E>  decorated = new TransformedSortedBag<E>(bag, transformer);
-        if (bag.size() > 0) {
+        if (transformer != null && bag != null && bag.size() > 0) {
             @SuppressWarnings("unchecked") // bag is type E
             final E[] values = (E[]) bag.toArray(); // NOPMD - false positive for generics
             bag.clear();
@@ -96,7 +96,7 @@ public class TransformedSortedBag<E> extends TransformedBag<E> implements Sorted
      *
      * @param bag  the bag to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
-     * @throws NullPointerException if bag or transformer is null
+     * @throws IllegalArgumentException if bag or transformer is null
      */
     protected TransformedSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {
         super(bag, transformer);
diff --git a/src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java b/src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java
index b01043d6..d9edb826 100644
--- a/src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java
+++ b/src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java
@@ -52,7 +52,7 @@ public final class UnmodifiableBag<E>
      * @param <E> the type of the elements in the bag
      * @param bag  the bag to decorate, must not be null
      * @return an unmodifiable Bag
-     * @throws NullPointerException if bag is null
+     * @throws IllegalArgumentException if bag is null
      * @since 4.0
      */
     public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {
@@ -69,7 +69,7 @@ public final class UnmodifiableBag<E>
      * Constructor that wraps (not copies).
      *
      * @param bag  the bag to decorate, must not be null
-     * @throws NullPointerException if bag is null
+     * @throws IllegalArgumentException if bag is null
      */
     @SuppressWarnings("unchecked") // safe to upcast
     private UnmodifiableBag(final Bag<? extends E> bag) {
diff --git a/src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java b/src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java
index 14399883..77f35a7a 100644
--- a/src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java
+++ b/src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java
@@ -52,7 +52,7 @@ public final class UnmodifiableSortedBag<E>
      * @param <E> the type of the elements in the bag
      * @param bag  the bag to decorate, must not be null
      * @return an unmodifiable SortedBag
-     * @throws NullPointerException if bag is null
+     * @throws IllegalArgumentException if bag is null
      * @since 4.0
      */
     public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {
@@ -67,7 +67,7 @@ public final class UnmodifiableSortedBag<E>
      * Constructor that wraps (not copies).
      *
      * @param bag  the bag to decorate, must not be null
-     * @throws NullPointerException if bag is null
+     * @throws IllegalArgumentException if bag is null
      */
     private UnmodifiableSortedBag(final SortedBag<E> bag) {
         super(bag);
diff --git a/src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java b/src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java
index fad9f058..d1bd4f5a 100644
--- a/src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java
@@ -44,7 +44,7 @@ public abstract class AbstractBidiMapDecorator<K, V>
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if the collection is null
+     * @throws IllegalArgumentException if the collection is null
      */
     protected AbstractBidiMapDecorator(final BidiMap<K, V> map) {
         super(map);
diff --git a/src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java b/src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java
index 7572e1ed..01b3beea 100644
--- a/src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java
@@ -42,7 +42,7 @@ public abstract class AbstractOrderedBidiMapDecorator<K, V>
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if the collection is null
+     * @throws IllegalArgumentException if the collection is null
      */
     protected AbstractOrderedBidiMapDecorator(final OrderedBidiMap<K, V> map) {
         super(map);
diff --git a/src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java b/src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java
index 70275eaf..47d68b50 100644
--- a/src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java
@@ -43,7 +43,7 @@ public abstract class AbstractSortedBidiMapDecorator<K, V>
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if the collection is null
+     * @throws IllegalArgumentException if the collection is null
      */
     public AbstractSortedBidiMapDecorator(final SortedBidiMap<K, V> map) {
         super(map);
diff --git a/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java b/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java
index 0b59dd7d..6f66d668 100644
--- a/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java
+++ b/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java
@@ -49,7 +49,7 @@ public final class UnmodifiableBidiMap<K, V>
      * @param <V> the value type
      * @param map  the map to decorate, must not be null
      * @return an unmodifiable BidiMap
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      * @since 4.0
      */
     public static <K, V> BidiMap<K, V> unmodifiableBidiMap(final BidiMap<? extends K, ? extends V> map) {
@@ -66,7 +66,7 @@ public final class UnmodifiableBidiMap<K, V>
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      */
     @SuppressWarnings("unchecked") // safe to upcast
     private UnmodifiableBidiMap(final BidiMap<? extends K, ? extends V> map) {
diff --git a/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java b/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java
index 73d4fd97..88e00f10 100644
--- a/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java
+++ b/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java
@@ -49,7 +49,7 @@ public final class UnmodifiableOrderedBidiMap<K, V>
      * @param <V> the value type
      * @param map  the map to decorate, must not be null
      * @return an unmodifiable OrderedBidiMap
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      * @since 4.0
      */
     public static <K, V> OrderedBidiMap<K, V> unmodifiableOrderedBidiMap(
@@ -67,7 +67,7 @@ public final class UnmodifiableOrderedBidiMap<K, V>
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      */
     @SuppressWarnings("unchecked") // safe to upcast
     private UnmodifiableOrderedBidiMap(final OrderedBidiMap<? extends K, ? extends V> map) {
diff --git a/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java b/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java
index 398a2cfd..a33e3863 100644
--- a/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java
+++ b/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java
@@ -51,7 +51,7 @@ public final class UnmodifiableSortedBidiMap<K, V>
      * @param <V> the value type
      * @param map  the map to decorate, must not be null
      * @return an unmodifiable SortedBidiMap
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      * @since 4.0
      */
     public static <K, V> SortedBidiMap<K, V> unmodifiableSortedBidiMap(final SortedBidiMap<K, ? extends V> map) {
@@ -68,7 +68,7 @@ public final class UnmodifiableSortedBidiMap<K, V>
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      */
     @SuppressWarnings("unchecked") // safe to upcast
     private UnmodifiableSortedBidiMap(final SortedBidiMap<K, ? extends V> map) {
diff --git a/src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java b/src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java
index 4d2dede4..b9245169 100644
--- a/src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java
@@ -73,11 +73,11 @@ public abstract class AbstractCollectionDecorator<E>
      * Constructor that wraps (not copies).
      *
      * @param coll  the collection to decorate, must not be null
-     * @throws NullPointerException if the collection is null
+     * @throws IllegalArgumentException if the collection is null
      */
     protected AbstractCollectionDecorator(final Collection<E> coll) {
         if (coll == null) {
-            throw new NullPointerException("Collection must not be null.");
+            throw new IllegalArgumentException("Collection must not be null");
         }
         this.collection = coll;
     }
diff --git a/src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java b/src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java
index b608dd75..7df27fc2 100644
--- a/src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java
+++ b/src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java
@@ -94,7 +94,7 @@ public class PredicatedCollection<E> extends AbstractCollectionDecorator<E> {
      * @param coll  the collection to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
      * @return a new predicated collection
-     * @throws NullPointerException if collection or predicate is null
+     * @throws IllegalArgumentException if collection or predicate is null
      * @throws IllegalArgumentException if the collection contains invalid elements
      * @since 4.0
      */
@@ -112,13 +112,13 @@ public class PredicatedCollection<E> extends AbstractCollectionDecorator<E> {
      *
      * @param coll  the collection to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
-     * @throws NullPointerException if collection or predicate is null
+     * @throws IllegalArgumentException if collection or predicate is null
      * @throws IllegalArgumentException if the collection contains invalid elements
      */
     protected PredicatedCollection(final Collection<E> coll, final Predicate<? super E> predicate) {
         super(coll);
         if (predicate == null) {
-            throw new NullPointerException("Predicate must not be null.");
+            throw new IllegalArgumentException("Predicate must not be null");
         }
         this.predicate = predicate;
         for (final E item : coll) {
@@ -216,11 +216,11 @@ public class PredicatedCollection<E> extends AbstractCollectionDecorator<E> {
          * Constructs a PredicatedCollectionBuilder with the specified Predicate.
          *
          * @param predicate  the predicate to use
-         * @throws NullPointerException if predicate is null
+         * @throws IllegalArgumentException if predicate is null
          */
         public Builder(final Predicate<? super E> predicate) {
             if (predicate == null) {
-                throw new NullPointerException("Predicate must not be null");
+                throw new IllegalArgumentException("Predicate must not be null");
             }
             this.predicate = predicate;
         }
@@ -282,12 +282,11 @@ public class PredicatedCollection<E> extends AbstractCollectionDecorator<E> {
          *
          * @param list  the List to decorate, must not be null
          * @return the decorated list.
-         * @throws NullPointerException if list is null
-         * @throws IllegalArgumentException if list contains invalid elements
+         * @throws IllegalArgumentException if list is null or contains invalid elements
          */
         public List<E> createPredicatedList(final List<E> list) {
             if (list == null) {
-                throw new NullPointerException("List must not be null.");
+                throw new IllegalArgumentException("list must not be null");
             }
             final List<E> predicatedList = PredicatedList.predicatedList(list, predicate);
             predicatedList.addAll(accepted);
@@ -315,12 +314,11 @@ public class PredicatedCollection<E> extends AbstractCollectionDecorator<E> {
          *
          * @param set  the set to decorate, must not be null
          * @return the decorated set.
-         * @throws NullPointerException if set is null
-         * @throws IllegalArgumentException if set contains invalid elements
+         * @throws IllegalArgumentException if set is null or contains invalid elements
          */
         public Set<E> createPredicatedSet(final Set<E> set) {
             if (set == null) {
-                throw new NullPointerException("Set must not be null.");
+                throw new IllegalArgumentException("set must not be null");
             }
             final PredicatedSet<E> predicatedSet = PredicatedSet.predicatedSet(set, predicate);
             predicatedSet.addAll(accepted);
@@ -348,12 +346,11 @@ public class PredicatedCollection<E> extends AbstractCollectionDecorator<E> {
          *
          * @param bag  the bag to decorate, must not be null
          * @return the decorated bag.
-         * @throws NullPointerException if bag is null
-         * @throws IllegalArgumentException if bag contains invalid elements
+         * @throws IllegalArgumentException if bag is null or contains invalid elements
          */
         public Bag<E> createPredicatedBag(final Bag<E> bag) {
             if (bag == null) {
-                throw new NullPointerException("Bag must not be null.");
+                throw new IllegalArgumentException("bag must not be null");
             }
             final PredicatedBag<E> predicatedBag = PredicatedBag.predicatedBag(bag, predicate);
             predicatedBag.addAll(accepted);
@@ -381,12 +378,11 @@ public class PredicatedCollection<E> extends AbstractCollectionDecorator<E> {
          *
          * @param queue  the queue to decorate, must not be null
          * @return the decorated queue.
-         * @throws NullPointerException if queue is null
-         * @throws IllegalArgumentException if queue contains invalid elements
+         * @throws IllegalArgumentException if queue is null or contains invalid elements
          */
         public Queue<E> createPredicatedQueue(final Queue<E> queue) {
             if (queue == null) {
-                throw new NullPointerException("queue must not be null");
+                throw new IllegalArgumentException("queue must not be null");
             }
             final PredicatedQueue<E> predicatedQueue = PredicatedQueue.predicatedQueue(queue, predicate);
             predicatedQueue.addAll(accepted);
diff --git a/src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java b/src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java
index e09ea8bb..567a65b6 100644
--- a/src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java
+++ b/src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java
@@ -54,7 +54,7 @@ public class SynchronizedCollection<E> implements Collection<E>, Serializable {
      * @param <T> the type of the elements in the collection
      * @param coll  the collection to decorate, must not be null
      * @return a new synchronized collection
-     * @throws NullPointerException if collection is null
+     * @throws IllegalArgumentException if collection is null
      * @since 4.0
      */
     public static <T> SynchronizedCollection<T> synchronizedCollection(final Collection<T> coll) {
@@ -66,11 +66,11 @@ public class SynchronizedCollection<E> implements Collection<E>, Serializable {
      * Constructor that wraps (not copies).
      *
      * @param collection  the collection to decorate, must not be null
-     * @throws NullPointerException if the collection is null
+     * @throws IllegalArgumentException if the collection is null
      */
     protected SynchronizedCollection(final Collection<E> collection) {
         if (collection == null) {
-            throw new NullPointerException("Collection must not be null.");
+            throw new IllegalArgumentException("Collection must not be null");
         }
         this.collection = collection;
         this.lock = this;
@@ -81,14 +81,11 @@ public class SynchronizedCollection<E> implements Collection<E>, Serializable {
      *
      * @param collection  the collection to decorate, must not be null
      * @param lock  the lock object to use, must not be null
-     * @throws NullPointerException if the collection or lock is null
+     * @throws IllegalArgumentException if the collection is null
      */
     protected SynchronizedCollection(final Collection<E> collection, final Object lock) {
         if (collection == null) {
-            throw new NullPointerException("Collection must not be null.");
-        }
-        if (lock == null) {
-            throw new NullPointerException("Lock must not be null.");
+            throw new IllegalArgumentException("Collection must not be null");
         }
         this.collection = collection;
         this.lock = lock;
diff --git a/src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java b/src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java
index 60342583..f4940473 100644
--- a/src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java
+++ b/src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java
@@ -55,7 +55,7 @@ public class TransformedCollection<E> extends AbstractCollectionDecorator<E> {
      * @param coll  the collection to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed collection
-     * @throws NullPointerException if collection or transformer is null
+     * @throws IllegalArgumentException if collection or transformer is null
      * @since 4.0
      */
     public static <E> TransformedCollection<E> transformingCollection(final Collection<E> coll,
@@ -75,7 +75,7 @@ public class TransformedCollection<E> extends AbstractCollectionDecorator<E> {
      * @param collection  the collection to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed Collection
-     * @throws NullPointerException if collection or transformer is null
+     * @throws IllegalArgumentException if collection or transformer is null
      * @since 4.0
      */
     public static <E> TransformedCollection<E> transformedCollection(final Collection<E> collection,
@@ -103,12 +103,12 @@ public class TransformedCollection<E> extends AbstractCollectionDecorator<E> {
      *
      * @param coll  the collection to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
-     * @throws NullPointerException if collection or transformer is null
+     * @throws IllegalArgumentException if collection or transformer is null
      */
     protected TransformedCollection(final Collection<E> coll, final Transformer<? super E, ? extends E> transformer) {
         super(coll);
         if (transformer == null) {
-            throw new NullPointerException("Transformer must not be null");
+            throw new IllegalArgumentException("Transformer must not be null");
         }
         this.transformer = transformer;
     }
diff --git a/src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java b/src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java
index 323f7b4c..9af8d5d7 100644
--- a/src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java
+++ b/src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java
@@ -52,7 +52,7 @@ public final class UnmodifiableBoundedCollection<E> extends AbstractCollectionDe
      * @param <E> the type of the elements in the collection
      * @param coll  the <code>BoundedCollection</code> to decorate, must not be null
      * @return a new unmodifiable bounded collection
-     * @throws NullPointerException if {@code coll} is {@code null}
+     * @throws IllegalArgumentException if {@code coll} is {@code null}
      * @since 4.0
      */
     public static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {
@@ -73,14 +73,13 @@ public final class UnmodifiableBoundedCollection<E> extends AbstractCollectionDe
      * @param <E> the type of the elements in the collection
      * @param coll  the <code>BoundedCollection</code> to decorate, must not be null
      * @return a new unmodifiable bounded collection
-     * @throws NullPointerException if coll is null
-     * @throws IllegalArgumentException if coll is not a {@code BoundedCollection}
+     * @throws IllegalArgumentException if {@code coll} is {@code null}
      * @since 4.0
      */
     @SuppressWarnings("unchecked")
     public static <E> BoundedCollection<E> unmodifiableBoundedCollection(Collection<? extends E> coll) {
         if (coll == null) {
-            throw new NullPointerException("Collection must not be null.");
+            throw new IllegalArgumentException("The collection must not be null");
         }
 
         // handle decorators
@@ -96,7 +95,7 @@ public final class UnmodifiableBoundedCollection<E> extends AbstractCollectionDe
         }
 
         if (coll instanceof BoundedCollection == false) {
-            throw new IllegalArgumentException("Collection is not a bounded collection.");
+            throw new IllegalArgumentException("The collection is not a bounded collection");
         }
         return new UnmodifiableBoundedCollection<E>((BoundedCollection<E>) coll);
     }
@@ -105,7 +104,7 @@ public final class UnmodifiableBoundedCollection<E> extends AbstractCollectionDe
      * Constructor that wraps (not copies).
      *
      * @param coll  the collection to decorate, must not be null
-     * @throws NullPointerException if coll is null
+     * @throws IllegalArgumentException if coll is null
      */
     @SuppressWarnings("unchecked") // safe to upcast
     private UnmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {
diff --git a/src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java b/src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java
index 8d248b33..5d2763cd 100644
--- a/src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java
+++ b/src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java
@@ -48,7 +48,7 @@ public final class UnmodifiableCollection<E>
      * @param <T> the type of the elements in the collection
      * @param coll  the collection to decorate, must not be null
      * @return an unmodifiable collection
-     * @throws NullPointerException if collection is null
+     * @throws IllegalArgumentException if collection is null
      * @since 4.0
      */
     public static <T> Collection<T> unmodifiableCollection(final Collection<? extends T> coll) {
@@ -65,7 +65,7 @@ public final class UnmodifiableCollection<E>
      * Constructor that wraps (not copies).
      *
      * @param coll  the collection to decorate, must not be null
-     * @throws NullPointerException if collection is null
+     * @throws IllegalArgumentException if collection is null
      */
     @SuppressWarnings("unchecked") // safe to upcast
     private UnmodifiableCollection(final Collection<? extends E> coll) {
diff --git a/src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java b/src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java
index d852883b..ae0133d3 100644
--- a/src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java
+++ b/src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java
@@ -87,12 +87,12 @@ public class FixedOrderComparator<T> implements Comparator<T>, Serializable {
      * The array is copied, so later changes will not affect the comparator.
      *
      * @param items  the items that the comparator can compare in order
-     * @throws NullPointerException if the array is null
+     * @throws IllegalArgumentException if the array is null
      */
     public FixedOrderComparator(final T... items) {
         super();
         if (items == null) {
-            throw new NullPointerException("The list of items must not be null");
+            throw new IllegalArgumentException("The list of items must not be null");
         }
         for (final T item : items) {
             add(item);
@@ -106,12 +106,12 @@ public class FixedOrderComparator<T> implements Comparator<T>, Serializable {
      * The list is copied, so later changes will not affect the comparator.
      *
      * @param items  the items that the comparator can compare in order
-     * @throws NullPointerException if the list is null
+     * @throws IllegalArgumentException if the list is null
      */
     public FixedOrderComparator(final List<T> items) {
         super();
         if (items == null) {
-            throw new NullPointerException("The list of items must not be null");
+            throw new IllegalArgumentException("The list of items must not be null");
         }
         for (final T t : items) {
             add(t);
@@ -157,12 +157,12 @@ public class FixedOrderComparator<T> implements Comparator<T>, Serializable {
      * @param unknownObjectBehavior  the flag for unknown behaviour -
      * UNKNOWN_AFTER, UNKNOWN_BEFORE or UNKNOWN_THROW_EXCEPTION
      * @throws UnsupportedOperationException if a comparison has been performed
-     * @throws NullPointerException if unknownObjectBehavior is null
+     * @throws IllegalArgumentException if the unknown flag is not valid
      */
     public void setUnknownObjectBehavior(final UnknownObjectBehavior unknownObjectBehavior) {
         checkLocked();
         if (unknownObjectBehavior == null) {
-            throw new NullPointerException("Unknown object behavior must not be null");
+            throw new IllegalArgumentException("Unknown object behavior must not be null");
         }
         this.unknownObjectBehavior = unknownObjectBehavior;
     }
diff --git a/src/main/java/org/apache/commons/collections4/functors/AllPredicate.java b/src/main/java/org/apache/commons/collections4/functors/AllPredicate.java
index 83456485..f6da168b 100644
--- a/src/main/java/org/apache/commons/collections4/functors/AllPredicate.java
+++ b/src/main/java/org/apache/commons/collections4/functors/AllPredicate.java
@@ -49,8 +49,8 @@ public final class AllPredicate<T> extends AbstractQuantifierPredicate<T> {
      * @param <T> the type that the predicate queries
      * @param predicates  the predicates to check, cloned, not null
      * @return the <code>all</code> predicate
-     * @throws NullPointerException if the predicates array is null
-     * @throws NullPointerException if any predicate in the array is null
+     * @throws IllegalArgumentException if the predicates array is null
+     * @throws IllegalArgumentException if any predicate in the array is null
      */
     public static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {
         FunctorUtils.validate(predicates);
@@ -73,8 +73,8 @@ public final class AllPredicate<T> extends AbstractQuantifierPredicate<T> {
      * @param <T> the type that the predicate queries
      * @param predicates  the predicates to check, cloned, not null
      * @return the <code>all</code> predicate
-     * @throws NullPointerException if the predicates array is null
-     * @throws NullPointerException if any predicate in the array is null
+     * @throws IllegalArgumentException if the predicates array is null
+     * @throws IllegalArgumentException if any predicate in the array is null
      */
     public static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {
         final Predicate<? super T>[] preds = validate(predicates);
diff --git a/src/main/java/org/apache/commons/collections4/functors/AndPredicate.java b/src/main/java/org/apache/commons/collections4/functors/AndPredicate.java
index fa333e13..514fc536 100644
--- a/src/main/java/org/apache/commons/collections4/functors/AndPredicate.java
+++ b/src/main/java/org/apache/commons/collections4/functors/AndPredicate.java
@@ -43,12 +43,12 @@ public final class AndPredicate<T> implements PredicateDecorator<T>, Serializabl
      * @param predicate1  the first predicate to check, not null
      * @param predicate2  the second predicate to check, not null
      * @return the <code>and</code> predicate
-     * @throws NullPointerException if either predicate is null
+     * @throws IllegalArgumentException if either predicate is null
      */
     public static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1,
                                                 final Predicate<? super T> predicate2) {
         if (predicate1 == null || predicate2 == null) {
-            throw new NullPointerException("Predicate must not be null");
+            throw new IllegalArgumentException("Predicate must not be null");
         }
         return new AndPredicate<T>(predicate1, predicate2);
     }
diff --git a/src/main/java/org/apache/commons/collections4/functors/AnyPredicate.java b/src/main/java/org/apache/commons/collections4/functors/AnyPredicate.java
index 1d825e60..522e7662 100644
--- a/src/main/java/org/apache/commons/collections4/functors/AnyPredicate.java
+++ b/src/main/java/org/apache/commons/collections4/functors/AnyPredicate.java
@@ -45,8 +45,8 @@ public final class AnyPredicate<T> extends AbstractQuantifierPredicate<T> {
      * @param <T> the type that the predicate queries
      * @param predicates  the predicates to check, cloned, not null
      * @return the <code>any</code> predicate
-     * @throws NullPointerException if the predicates array is null
-     * @throws NullPointerException if any predicate in the array is null
+     * @throws IllegalArgumentException if the predicates array is null
+     * @throws IllegalArgumentException if any predicate in the array is null
      */
     @SuppressWarnings("unchecked")
     public static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {
@@ -69,8 +69,8 @@ public final class AnyPredicate<T> extends AbstractQuantifierPredicate<T> {
      * @param <T> the type that the predicate queries
      * @param predicates  the predicates to check, cloned, not null
      * @return the <code>all</code> predicate
-     * @throws NullPointerException if the predicates array is null
-     * @throws NullPointerException if any predicate in the array is null
+     * @throws IllegalArgumentException if the predicates array is null
+     * @throws IllegalArgumentException if any predicate in the array is null
      */
     @SuppressWarnings("unchecked")
     public static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {
diff --git a/src/main/java/org/apache/commons/collections4/functors/ChainedClosure.java b/src/main/java/org/apache/commons/collections4/functors/ChainedClosure.java
index 96497eb2..2d8c8587 100644
--- a/src/main/java/org/apache/commons/collections4/functors/ChainedClosure.java
+++ b/src/main/java/org/apache/commons/collections4/functors/ChainedClosure.java
@@ -41,8 +41,8 @@ public class ChainedClosure<E> implements Closure<E>, Serializable {
      * @param <E> the type that the closure acts on
      * @param closures  the closures to chain, copied, no nulls
      * @return the <code>chained</code> closure
-     * @throws NullPointerException if the closures array is null
-     * @throws NullPointerException if any closure in the array is null
+     * @throws IllegalArgumentException if the closures array is null
+     * @throws IllegalArgumentException if any closure in the array is null
      */
     public static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {
         FunctorUtils.validate(closures);
@@ -60,13 +60,13 @@ public class ChainedClosure<E> implements Closure<E>, Serializable {
      * @param <E> the type that the closure acts on
      * @param closures  a collection of closures to chain
      * @return the <code>chained</code> closure
-     * @throws NullPointerException if the closures collection is null
-     * @throws NullPointerException if any closure in the collection is null
+     * @throws IllegalArgumentException if the closures collection is null
+     * @throws IllegalArgumentException if any closure in the collection is null
      */
     @SuppressWarnings("unchecked")
     public static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {
         if (closures == null) {
-            throw new NullPointerException("Closure collection must not be null");
+            throw new IllegalArgumentException("Closure collection must not be null");
         }
         if (closures.size() == 0) {
             return NOPClosure.<E>nopClosure();
diff --git a/src/main/java/org/apache/commons/collections4/functors/ChainedTransformer.java b/src/main/java/org/apache/commons/collections4/functors/ChainedTransformer.java
index 0f925b21..1892ddd3 100644
--- a/src/main/java/org/apache/commons/collections4/functors/ChainedTransformer.java
+++ b/src/main/java/org/apache/commons/collections4/functors/ChainedTransformer.java
@@ -44,8 +44,8 @@ public class ChainedTransformer<T> implements Transformer<T, T>, Serializable {
      * @param <T>  the object type
      * @param transformers  the transformers to chain, copied, no nulls
      * @return the <code>chained</code> transformer
-     * @throws NullPointerException if the transformers array is null
-     * @throws NullPointerException if any transformer in the array is null
+     * @throws IllegalArgumentException if the transformers array is null
+     * @throws IllegalArgumentException if any transformer in the array is null
      */
     public static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>... transformers) {
         FunctorUtils.validate(transformers);
@@ -63,14 +63,14 @@ public class ChainedTransformer<T> implements Transformer<T, T>, Serializable {
      * @param <T>  the object type
      * @param transformers  a collection of transformers to chain
      * @return the <code>chained</code> transformer
-     * @throws NullPointerException if the transformers collection is null
-     * @throws NullPointerException if any transformer in the collection is null
+     * @throws IllegalArgumentException if the transformers collection is null
+     * @throws IllegalArgumentException if any transformer in the collection is null
      */
     @SuppressWarnings("unchecked")
     public static <T> Transformer<T, T> chainedTransformer(
             final Collection<? extends Transformer<? super T, ? extends T>> transformers) {
         if (transformers == null) {
-            throw new NullPointerException("Transformer collection must not be null");
+            throw new IllegalArgumentException("Transformer collection must not be null");
         }
         if (transformers.size() == 0) {
             return NOPTransformer.<T>nopTransformer();
diff --git a/src/main/java/org/apache/commons/collections4/functors/ClosureTransformer.java b/src/main/java/org/apache/commons/collections4/functors/ClosureTransformer.java
index fbe92b72..fbf2c913 100644
--- a/src/main/java/org/apache/commons/collections4/functors/ClosureTransformer.java
+++ b/src/main/java/org/apache/commons/collections4/functors/ClosureTransformer.java
@@ -42,11 +42,11 @@ public class ClosureTransformer<T> implements Transformer<T, T>, Serializable {
      * @param <T>  the type of the object to transform
      * @param closure  the closure to call, not null
      * @return the <code>closure</code> transformer
-     * @throws NullPointerException if the closure is null
+     * @throws IllegalArgumentException if the closure is null
      */
     public static <T> Transformer<T, T> closureTransformer(final Closure<? super T> closure) {
         if (closure == null) {
-            throw new NullPointerException("Closure must not be null");
+            throw new IllegalArgumentException("Closure must not be null");
         }
         return new ClosureTransformer<T>(closure);
     }
diff --git a/src/main/java/org/apache/commons/collections4/functors/ComparatorPredicate.java b/src/main/java/org/apache/commons/collections4/functors/ComparatorPredicate.java
index e6ea395b..dd43b66b 100644
--- a/src/main/java/org/apache/commons/collections4/functors/ComparatorPredicate.java
+++ b/src/main/java/org/apache/commons/collections4/functors/ComparatorPredicate.java
@@ -102,7 +102,7 @@ public class ComparatorPredicate<T> implements Predicate<T>, Serializable {
      * @param object  the object to compare to
      * @param comparator  the comparator to use for comparison
      * @return the predicate
-     * @throws NullPointerException if comparator is null
+     * @throws IllegalArgumentException if comparator is null
      */
     public static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator) {
         return comparatorPredicate(object, comparator, Criterion.EQUAL);
@@ -116,15 +116,15 @@ public class ComparatorPredicate<T> implements Predicate<T>, Serializable {
      * @param comparator  the comparator to use for comparison
      * @param criterion  the criterion to use to evaluate comparison
      * @return the predicate
-     * @throws NullPointerException if comparator or criterion is null
+     * @throws IllegalArgumentException if comparator is null of criterion is invalid
      */
     public static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator,
                                                        final Criterion criterion) {
         if (comparator == null) {
-            throw new NullPointerException("Comparator must not be null.");
+            throw new IllegalArgumentException("Comparator must not be null.");
         }
         if (criterion == null) {
-            throw new NullPointerException("Criterion must not be null.");
+            throw new IllegalArgumentException("Criterion must not be null.");
         }
         return new ComparatorPredicate<T>(object, comparator, criterion);
     }
diff --git a/src/main/java/org/apache/commons/collections4/functors/FactoryTransformer.java b/src/main/java/org/apache/commons/collections4/functors/FactoryTransformer.java
index b820707a..96613b8a 100644
--- a/src/main/java/org/apache/commons/collections4/functors/FactoryTransformer.java
+++ b/src/main/java/org/apache/commons/collections4/functors/FactoryTransformer.java
@@ -42,11 +42,11 @@ public class FactoryTransformer<I, O> implements Transformer<I, O>, Serializable
      * @param <O>  the output type
      * @param factory  the factory to call, not null
      * @return the <code>factory</code> transformer
-     * @throws NullPointerException if the factory is null
+     * @throws IllegalArgumentException if the factory is null
      */
     public static <I, O> Transformer<I, O> factoryTransformer(final Factory<? extends O> factory) {
         if (factory == null) {
-            throw new NullPointerException("Factory must not be null");
+            throw new IllegalArgumentException("Factory must not be null");
         }
         return new FactoryTransformer<I, O>(factory);
     }
diff --git a/src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java b/src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java
index aed237ee..89c66072 100644
--- a/src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java
+++ b/src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java
@@ -77,11 +77,11 @@ class FunctorUtils {
      */
     static void validate(final Predicate<?>... predicates) {
         if (predicates == null) {
-            throw new NullPointerException("The predicate array must not be null");
+            throw new IllegalArgumentException("The predicate array must not be null");
         }
         for (int i = 0; i < predicates.length; i++) {
             if (predicates[i] == null) {
-                throw new NullPointerException(
+                throw new IllegalArgumentException(
                         "The predicate array must not contain a null predicate, index " + i + " was null");
             }
         }
@@ -95,7 +95,7 @@ class FunctorUtils {
      */
     static <T> Predicate<? super T>[] validate(final Collection<? extends Predicate<? super T>> predicates) {
         if (predicates == null) {
-            throw new NullPointerException("The predicate collection must not be null");
+            throw new IllegalArgumentException("The predicate collection must not be null");
         }
         // convert to array like this to guarantee iterator() ordering
         @SuppressWarnings("unchecked") // OK
@@ -104,7 +104,7 @@ class FunctorUtils {
         for (final Predicate<? super T> predicate : predicates) {
             preds[i] = predicate;
             if (preds[i] == null) {
-                throw new NullPointerException(
+                throw new IllegalArgumentException(
                         "The predicate collection must not contain a null predicate, index " + i + " was null");
             }
             i++;
@@ -133,11 +133,11 @@ class FunctorUtils {
      */
     static void validate(final Closure<?>... closures) {
         if (closures == null) {
-            throw new NullPointerException("The closure array must not be null");
+            throw new IllegalArgumentException("The closure array must not be null");
         }
         for (int i = 0; i < closures.length; i++) {
             if (closures[i] == null) {
-                throw new NullPointerException(
+                throw new IllegalArgumentException(
                         "The closure array must not contain a null closure, index " + i + " was null");
             }
         }
@@ -179,11 +179,11 @@ class FunctorUtils {
      */
     static void validate(final Transformer<?, ?>... transformers) {
         if (transformers == null) {
-            throw new NullPointerException("The transformer array must not be null");
+            throw new IllegalArgumentException("The transformer array must not be null");
         }
         for (int i = 0; i < transformers.length; i++) {
             if (transformers[i] == null) {
-                throw new NullPointerException(
+                throw new IllegalArgumentException(
                     "The transformer array must not contain a null transformer, index " + i + " was null");
             }
         }
diff --git a/src/main/java/org/apache/commons/collections4/functors/IdentityPredicate.java b/src/main/java/org/apache/commons/collections4/functors/IdentityPredicate.java
index abb4645f..7f7de133 100644
--- a/src/main/java/org/apache/commons/collections4/functors/IdentityPredicate.java
+++ b/src/main/java/org/apache/commons/collections4/functors/IdentityPredicate.java
@@ -41,6 +41,7 @@ public final class IdentityPredicate<T> implements Predicate<T>, Serializable {
      * @param <T> the type that the predicate queries
      * @param object  the object to compare to
      * @return the predicate
+     * @throws IllegalArgumentException if the predicate is null
      */
     public static <T> Predicate<T> identityPredicate(final T object) {
         if (object == null) {
diff --git a/src/main/java/org/apache/commons/collections4/functors/IfClosure.java b/src/main/java/org/apache/commons/collections4/functors/IfClosure.java
index 19a5e60d..4b39c945 100644
--- a/src/main/java/org/apache/commons/collections4/functors/IfClosure.java
+++ b/src/main/java/org/apache/commons/collections4/functors/IfClosure.java
@@ -50,7 +50,7 @@ public class IfClosure<E> implements Closure<E>, Serializable {
      * @param predicate  predicate to switch on
      * @param trueClosure  closure used if true
      * @return the <code>if</code> closure
-     * @throws NullPointerException if either argument is null
+     * @throws IllegalArgumentException if either argument is null
      * @since 3.2
      */
     public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {
@@ -65,16 +65,16 @@ public class IfClosure<E> implements Closure<E>, Serializable {
      * @param trueClosure  closure used if true
      * @param falseClosure  closure used if false
      * @return the <code>if</code> closure
-     * @throws NullPointerException if any argument is null
+     * @throws IllegalArgumentException if any argument is null
      */
     public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,
                                            final Closure<? super E> trueClosure,
                                            final Closure<? super E> falseClosure) {
         if (predicate == null) {
-            throw new NullPointerException("Predicate must not be null");
+            throw new IllegalArgumentException("Predicate must not be null");
         }
         if (trueClosure == null || falseClosure == null) {
-            throw new NullPointerException("Closures must not be null");
+            throw new IllegalArgumentException("Closures must not be null");
         }
         return new IfClosure<E>(predicate, trueClosure, falseClosure);
     }
diff --git a/src/main/java/org/apache/commons/collections4/functors/IfTransformer.java b/src/main/java/org/apache/commons/collections4/functors/IfTransformer.java
index 431f3e0b..510afa31 100644
--- a/src/main/java/org/apache/commons/collections4/functors/IfTransformer.java
+++ b/src/main/java/org/apache/commons/collections4/functors/IfTransformer.java
@@ -16,11 +16,11 @@
  */
 package org.apache.commons.collections4.functors;
 
-import java.io.Serializable;
-
 import org.apache.commons.collections4.Predicate;
 import org.apache.commons.collections4.Transformer;
 
+import java.io.Serializable;
+
 /**
  * Transformer implementation that will call one of two closures based on whether a predicate evaluates
  * as true or false.
@@ -52,16 +52,15 @@ public class IfTransformer<I, O> implements Transformer<I, O>, Serializable {
      * @param trueTransformer  transformer used if true
      * @param falseTransformer  transformer used if false
      * @return the <code>if</code> transformer
-     * @throws NullPointerException if either argument is null
      */
     public static <I, O> Transformer<I, O> ifTransformer(final Predicate<? super I> predicate,
                                                          final Transformer<? super I, ? extends O> trueTransformer,
                                                          final Transformer<? super I, ? extends O> falseTransformer) {
         if (predicate == null) {
-            throw new NullPointerException("Predicate must not be null");
+            throw new IllegalArgumentException("Predicate must not be null");
         }
         if (trueTransformer == null || falseTransformer == null) {
-            throw new NullPointerException("Transformers must not be null");
+            throw new IllegalArgumentException("Transformers must not be null");
         }
 
         return new IfTransformer<I, O>(predicate, trueTransformer, falseTransformer);
@@ -77,17 +76,16 @@ public class IfTransformer<I, O> implements Transformer<I, O>, Serializable {
      * @param predicate  predicate to switch on
      * @param trueTransformer  transformer used if true
      * @return the <code>if</code> transformer
-     * @throws NullPointerException if either argument is null
      */
     public static <T> Transformer<T, T> ifTransformer(
             final Predicate<? super T> predicate,
             final Transformer<? super T, ? extends T> trueTransformer) {
 
         if (predicate == null) {
-            throw new NullPointerException("Predicate must not be null");
+            throw new IllegalArgumentException("Predicate must not be null");
         }
         if (trueTransformer == null) {
-            throw new NullPointerException("Transformer must not be null");
+            throw new IllegalArgumentException("Transformer must not be null");
         }
 
         return new IfTransformer<T, T>(predicate, trueTransformer, NOPTransformer.<T>nopTransformer());
diff --git a/src/main/java/org/apache/commons/collections4/functors/InstanceofPredicate.java b/src/main/java/org/apache/commons/collections4/functors/InstanceofPredicate.java
index 6577d831..4545869e 100644
--- a/src/main/java/org/apache/commons/collections4/functors/InstanceofPredicate.java
+++ b/src/main/java/org/apache/commons/collections4/functors/InstanceofPredicate.java
@@ -40,11 +40,11 @@ public final class InstanceofPredicate implements Predicate<Object>, Serializabl
      *
      * @param type  the type to check for, may not be null
      * @return the predicate
-     * @throws NullPointerException if the class is null
+     * @throws IllegalArgumentException if the class is null
      */
     public static Predicate<Object> instanceOfPredicate(final Class<?> type) {
         if (type == null) {
-            throw new NullPointerException("The type to check instanceof must not be null");
+            throw new IllegalArgumentException("The type to check instanceof must not be null");
         }
         return new InstanceofPredicate(type);
     }
diff --git a/src/main/java/org/apache/commons/collections4/functors/InstantiateFactory.java b/src/main/java/org/apache/commons/collections4/functors/InstantiateFactory.java
index 1179b5e7..8a313f9d 100644
--- a/src/main/java/org/apache/commons/collections4/functors/InstantiateFactory.java
+++ b/src/main/java/org/apache/commons/collections4/functors/InstantiateFactory.java
@@ -51,14 +51,12 @@ public class InstantiateFactory<T> implements Factory<T>, Serializable {
      * @param paramTypes  the constructor parameter types, cloned
      * @param args  the constructor arguments, cloned
      * @return a new instantiate factory
-     * @throws NullPointerException if classToInstantiate is null
-     * @throws IllegalArgumentException if paramTypes does not match args
      */
     public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate,
                                                     final Class<?>[] paramTypes,
                                                     final Object[] args) {
         if (classToInstantiate == null) {
-            throw new NullPointerException("Class to instantiate must not be null");
+            throw new IllegalArgumentException("Class to instantiate must not be null");
         }
         if (paramTypes == null && args != null
             || paramTypes != null && args == null
diff --git a/src/main/java/org/apache/commons/collections4/functors/InstantiateTransformer.java b/src/main/java/org/apache/commons/collections4/functors/InstantiateTransformer.java
index e5a000ea..8d947e3b 100644
--- a/src/main/java/org/apache/commons/collections4/functors/InstantiateTransformer.java
+++ b/src/main/java/org/apache/commons/collections4/functors/InstantiateTransformer.java
@@ -61,7 +61,6 @@ public class InstantiateTransformer<T> implements Transformer<Class<? extends T>
      * @param paramTypes  the constructor parameter types
      * @param args  the constructor arguments
      * @return an instantiate transformer
-     * @throws IllegalArgumentException if paramTypes does not match args
      */
     public static <T> Transformer<Class<? extends T>, T> instantiateTransformer(final Class<?>[] paramTypes,
                                                                                 final Object[] args) {
diff --git a/src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java b/src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java
index 09d79ef2..a1ba7d1d 100644
--- a/src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java
+++ b/src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java
@@ -48,12 +48,11 @@ public class InvokerTransformer<I, O> implements Transformer<I, O>, Serializable
      * @param <O>  the output type
      * @param methodName  the method name to call
      * @return an invoker transformer
-     * @throws NullPointerException if methodName is null
      * @since 3.1
      */
     public static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {
         if (methodName == null) {
-            throw new NullPointerException("The method to invoke must not be null");
+            throw new IllegalArgumentException("The method to invoke must not be null");
         }
         return new InvokerTransformer<I, O>(methodName);
     }
@@ -67,13 +66,11 @@ public class InvokerTransformer<I, O> implements Transformer<I, O>, Serializable
      * @param paramTypes  the parameter types of the method
      * @param args  the arguments to pass to the method
      * @return an invoker transformer
-     * @throws NullPointerException if methodName is null
-     * @throws IllegalArgumentException if paramTypes does not match args
      */
     public static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes,
                                                               final Object[] args) {
         if (methodName == null) {
-            throw new NullPointerException("The method to invoke must not be null");
+            throw new IllegalArgumentException("The method to invoke must not be null");
         }
         if (((paramTypes == null) && (args != null))
             || ((paramTypes != null) && (args == null))
diff --git a/src/main/java/org/apache/commons/collections4/functors/NonePredicate.java b/src/main/java/org/apache/commons/collections4/functors/NonePredicate.java
index 617f2e33..23ad4b87 100644
--- a/src/main/java/org/apache/commons/collections4/functors/NonePredicate.java
+++ b/src/main/java/org/apache/commons/collections4/functors/NonePredicate.java
@@ -44,8 +44,8 @@ public final class NonePredicate<T> extends AbstractQuantifierPredicate<T> {
      * @param <T> the type that the predicate queries
      * @param predicates  the predicates to check, cloned, not null
      * @return the <code>any</code> predicate
-     * @throws NullPointerException if the predicates array is null
-     * @throws NullPointerException if any predicate in the array is null
+     * @throws IllegalArgumentException if the predicates array is null
+     * @throws IllegalArgumentException if any predicate in the array is null
      */
     public static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {
         FunctorUtils.validate(predicates);
@@ -63,8 +63,8 @@ public final class NonePredicate<T> extends AbstractQuantifierPredicate<T> {
      * @param <T> the type that the predicate queries
      * @param predicates  the predicates to check, cloned, not null
      * @return the <code>one</code> predicate
-     * @throws NullPointerException if the predicates array is null
-     * @throws NullPointerException if any predicate in the array is null
+     * @throws IllegalArgumentException if the predicates array is null
+     * @throws IllegalArgumentException if any predicate in the array is null
      */
     public static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {
         final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);
diff --git a/src/main/java/org/apache/commons/collections4/functors/NotPredicate.java b/src/main/java/org/apache/commons/collections4/functors/NotPredicate.java
index b9876a01..97a58498 100644
--- a/src/main/java/org/apache/commons/collections4/functors/NotPredicate.java
+++ b/src/main/java/org/apache/commons/collections4/functors/NotPredicate.java
@@ -40,11 +40,11 @@ public final class NotPredicate<T> implements PredicateDecorator<T>, Serializabl
      * @param <T> the type that the predicate queries
      * @param predicate  the predicate to decorate, not null
      * @return the predicate
-     * @throws NullPointerException if the predicate is null
+     * @throws IllegalArgumentException if the predicate is null
      */
     public static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {
         if (predicate == null) {
-            throw new NullPointerException("Predicate must not be null");
+            throw new IllegalArgumentException("Predicate must not be null");
         }
         return new NotPredicate<T>(predicate);
     }
diff --git a/src/main/java/org/apache/commons/collections4/functors/NullIsExceptionPredicate.java b/src/main/java/org/apache/commons/collections4/functors/NullIsExceptionPredicate.java
index aa090ee8..744873e3 100644
--- a/src/main/java/org/apache/commons/collections4/functors/NullIsExceptionPredicate.java
+++ b/src/main/java/org/apache/commons/collections4/functors/NullIsExceptionPredicate.java
@@ -41,11 +41,11 @@ public final class NullIsExceptionPredicate<T> implements PredicateDecorator<T>,
      * @param <T> the type that the predicate queries
      * @param predicate  the predicate to decorate, not null
      * @return the predicate
-     * @throws NullPointerException if the predicate is null
+     * @throws IllegalArgumentException if the predicate is null
      */
     public static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {
         if (predicate == null) {
-            throw new NullPointerException("Predicate must not be null");
+            throw new IllegalArgumentException("Predicate must not be null");
         }
         return new NullIsExceptionPredicate<T>(predicate);
     }
diff --git a/src/main/java/org/apache/commons/collections4/functors/NullIsFalsePredicate.java b/src/main/java/org/apache/commons/collections4/functors/NullIsFalsePredicate.java
index c24878ba..e3c45874 100644
--- a/src/main/java/org/apache/commons/collections4/functors/NullIsFalsePredicate.java
+++ b/src/main/java/org/apache/commons/collections4/functors/NullIsFalsePredicate.java
@@ -40,11 +40,11 @@ public final class NullIsFalsePredicate<T> implements PredicateDecorator<T>, Ser
      * @param <T> the type that the predicate queries
      * @param predicate  the predicate to decorate, not null
      * @return the predicate
-     * @throws NullPointerException if the predicate is null
+     * @throws IllegalArgumentException if the predicate is null
      */
     public static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {
         if (predicate == null) {
-            throw new NullPointerException("Predicate must not be null");
+            throw new IllegalArgumentException("Predicate must not be null");
         }
         return new NullIsFalsePredicate<T>(predicate);
     }
diff --git a/src/main/java/org/apache/commons/collections4/functors/NullIsTruePredicate.java b/src/main/java/org/apache/commons/collections4/functors/NullIsTruePredicate.java
index 1eac13f2..ad4e6393 100644
--- a/src/main/java/org/apache/commons/collections4/functors/NullIsTruePredicate.java
+++ b/src/main/java/org/apache/commons/collections4/functors/NullIsTruePredicate.java
@@ -40,11 +40,11 @@ public final class NullIsTruePredicate<T> implements PredicateDecorator<T>, Seri
      * @param <T> the type that the predicate queries
      * @param predicate  the predicate to decorate, not null
      * @return the predicate
-     * @throws NullPointerException if the predicate is null
+     * @throws IllegalArgumentException if the predicate is null
      */
     public static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {
         if (predicate == null) {
-            throw new NullPointerException("Predicate must not be null");
+            throw new IllegalArgumentException("Predicate must not be null");
         }
         return new NullIsTruePredicate<T>(predicate);
     }
diff --git a/src/main/java/org/apache/commons/collections4/functors/OnePredicate.java b/src/main/java/org/apache/commons/collections4/functors/OnePredicate.java
index c4588d52..84aee438 100644
--- a/src/main/java/org/apache/commons/collections4/functors/OnePredicate.java
+++ b/src/main/java/org/apache/commons/collections4/functors/OnePredicate.java
@@ -45,8 +45,8 @@ public final class OnePredicate<T> extends AbstractQuantifierPredicate<T> {
      * @param <T> the type that the predicate queries
      * @param predicates  the predicates to check, cloned, not null
      * @return the <code>any</code> predicate
-     * @throws NullPointerException if the predicates array is null
-     * @throws NullPointerException if any predicate in the array is null
+     * @throws IllegalArgumentException if the predicates array is null
+     * @throws IllegalArgumentException if any predicate in the array is null
      */
     @SuppressWarnings("unchecked")
     public static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {
@@ -66,8 +66,8 @@ public final class OnePredicate<T> extends AbstractQuantifierPredicate<T> {
      * @param <T> the type that the predicate queries
      * @param predicates  the predicates to check, cloned, not null
      * @return the <code>one</code> predicate
-     * @throws NullPointerException if the predicates array is null
-     * @throws NullPointerException if any predicate in the array is null
+     * @throws IllegalArgumentException if the predicates array is null
+     * @throws IllegalArgumentException if any predicate in the array is null
      */
     public static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {
         final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);
diff --git a/src/main/java/org/apache/commons/collections4/functors/OrPredicate.java b/src/main/java/org/apache/commons/collections4/functors/OrPredicate.java
index dcd1992a..2321ee59 100644
--- a/src/main/java/org/apache/commons/collections4/functors/OrPredicate.java
+++ b/src/main/java/org/apache/commons/collections4/functors/OrPredicate.java
@@ -43,12 +43,12 @@ public final class OrPredicate<T> implements PredicateDecorator<T>, Serializable
      * @param predicate1  the first predicate to check, not null
      * @param predicate2  the second predicate to check, not null
      * @return the <code>and</code> predicate
-     * @throws NullPointerException if either predicate is null
+     * @throws IllegalArgumentException if either predicate is null
      */
     public static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1,
                                                final Predicate<? super T> predicate2) {
         if (predicate1 == null || predicate2 == null) {
-            throw new NullPointerException("Predicate must not be null");
+            throw new IllegalArgumentException("Predicate must not be null");
         }
         return new OrPredicate<T>(predicate1, predicate2);
     }
diff --git a/src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java b/src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java
index de6e5446..8c7edb0d 100644
--- a/src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java
+++ b/src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java
@@ -49,9 +49,8 @@ public class SwitchClosure<E> implements Closure<E>, Serializable {
      * @param closures  matching array of closures, cloned, no nulls
      * @param defaultClosure  the closure to use if no match, null means nop
      * @return the <code>chained</code> closure
-     * @throws NullPointerException if array is null
-     * @throws NullPointerException if any element in the array is null
-     * @throws IllegalArgumentException if the array lengths of predicates and closures do not match
+     * @throws IllegalArgumentException if array is null
+     * @throws IllegalArgumentException if any element in the array is null
      */
     @SuppressWarnings("unchecked")
     public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates,
@@ -82,14 +81,14 @@ public class SwitchClosure<E> implements Closure<E>, Serializable {
      * @param <E> the type that the closure acts on
      * @param predicatesAndClosures  a map of predicates to closures
      * @return the <code>switch</code> closure
-     * @throws NullPointerException if the map is null
-     * @throws NullPointerException if any closure in the map is null
+     * @throws IllegalArgumentException if the map is null
+     * @throws IllegalArgumentException if any closure in the map is null
      * @throws ClassCastException  if the map elements are of the wrong type
      */
     @SuppressWarnings("unchecked")
     public static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {
         if (predicatesAndClosures == null) {
-            throw new NullPointerException("The predicate and closure map must not be null");
+            throw new IllegalArgumentException("The predicate and closure map must not be null");
         }
         // convert to array like this to guarantee iterator() ordering
         final Closure<? super E> defaultClosure = predicatesAndClosures.remove(null);
diff --git a/src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java b/src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java
index defc3fe6..d24f8757 100644
--- a/src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java
+++ b/src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java
@@ -50,8 +50,8 @@ public class SwitchTransformer<I, O> implements Transformer<I, O>, Serializable
      * @param transformers  matching array of transformers, cloned, no nulls
      * @param defaultTransformer  the transformer to use if no match, null means return null
      * @return the <code>chained</code> transformer
-     * @throws NullPointerException if array is null
-     * @throws NullPointerException if any element in the array is null
+     * @throws IllegalArgumentException if array is null
+     * @throws IllegalArgumentException if any element in the array is null
      */
     @SuppressWarnings("unchecked")
     public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates,
@@ -84,8 +84,8 @@ public class SwitchTransformer<I, O> implements Transformer<I, O>, Serializable
      * @param <O>  the output type
      * @param map  a map of predicates to transformers
      * @return the <code>switch</code> transformer
-     * @throws NullPointerException if the map is null
-     * @throws NullPointerException if any transformer in the map is null
+     * @throws IllegalArgumentException if the map is null
+     * @throws IllegalArgumentException if any transformer in the map is null
      * @throws ClassCastException  if the map elements are of the wrong type
      */
     @SuppressWarnings("unchecked")
@@ -93,7 +93,7 @@ public class SwitchTransformer<I, O> implements Transformer<I, O>, Serializable
             final Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> map) {
 
         if (map == null) {
-            throw new NullPointerException("The predicate and transformer map must not be null");
+            throw new IllegalArgumentException("The predicate and transformer map must not be null");
         }
         if (map.size() == 0) {
             return ConstantTransformer.<I, O>nullTransformer();
diff --git a/src/main/java/org/apache/commons/collections4/functors/TransformedPredicate.java b/src/main/java/org/apache/commons/collections4/functors/TransformedPredicate.java
index 2278a26f..cdeb5b49 100644
--- a/src/main/java/org/apache/commons/collections4/functors/TransformedPredicate.java
+++ b/src/main/java/org/apache/commons/collections4/functors/TransformedPredicate.java
@@ -46,15 +46,15 @@ public final class TransformedPredicate<T> implements PredicateDecorator<T>, Ser
      * @param transformer  the transformer to call
      * @param predicate  the predicate to call with the result of the transform
      * @return the predicate
-     * @throws NullPointerException if the transformer or the predicate is null
+     * @throws IllegalArgumentException if the transformer or the predicate is null
      */
     public static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer,
                                                         final Predicate<? super T> predicate) {
         if (transformer == null) {
-            throw new NullPointerException("The transformer to call must not be null");
+            throw new IllegalArgumentException("The transformer to call must not be null");
         }
         if (predicate == null) {
-            throw new NullPointerException("The predicate to call must not be null");
+            throw new IllegalArgumentException("The predicate to call must not be null");
         }
         return new TransformedPredicate<T>(transformer, predicate);
     }
diff --git a/src/main/java/org/apache/commons/collections4/functors/TransformerPredicate.java b/src/main/java/org/apache/commons/collections4/functors/TransformerPredicate.java
index c3b03a22..df986b34 100644
--- a/src/main/java/org/apache/commons/collections4/functors/TransformerPredicate.java
+++ b/src/main/java/org/apache/commons/collections4/functors/TransformerPredicate.java
@@ -42,11 +42,11 @@ public final class TransformerPredicate<T> implements Predicate<T>, Serializable
      * @param <T> the type that the predicate queries
      * @param transformer  the transformer to decorate
      * @return the predicate
-     * @throws NullPointerException if the transformer is null
+     * @throws IllegalArgumentException if the transformer is null
      */
     public static <T> Predicate<T> transformerPredicate(final Transformer<? super T, Boolean> transformer) {
         if (transformer == null) {
-            throw new NullPointerException("The transformer to call must not be null");
+            throw new IllegalArgumentException("The transformer to call must not be null");
         }
         return new TransformerPredicate<T>(transformer);
     }
diff --git a/src/main/java/org/apache/commons/collections4/functors/WhileClosure.java b/src/main/java/org/apache/commons/collections4/functors/WhileClosure.java
index 525bc9a9..46e62019 100644
--- a/src/main/java/org/apache/commons/collections4/functors/WhileClosure.java
+++ b/src/main/java/org/apache/commons/collections4/functors/WhileClosure.java
@@ -48,15 +48,15 @@ public class WhileClosure<E> implements Closure<E>, Serializable {
      * @param closure  the closure the execute, not null
      * @param doLoop  true to act as a do-while loop, always executing the closure once
      * @return the <code>while</code> closure
-     * @throws NullPointerException if the predicate or closure is null
+     * @throws IllegalArgumentException if the predicate or closure is null
      */
     public static <E> Closure<E> whileClosure(final Predicate<? super E> predicate,
                                               final Closure<? super E> closure, final boolean doLoop) {
         if (predicate == null) {
-            throw new NullPointerException("Predicate must not be null");
+            throw new IllegalArgumentException("Predicate must not be null");
         }
         if (closure == null) {
-            throw new NullPointerException("Closure must not be null");
+            throw new IllegalArgumentException("Closure must not be null");
         }
         return new WhileClosure<E>(predicate, closure, doLoop);
     }
diff --git a/src/main/java/org/apache/commons/collections4/iterators/AbstractIteratorDecorator.java b/src/main/java/org/apache/commons/collections4/iterators/AbstractIteratorDecorator.java
index 5aa7117e..ddfc4fbf 100644
--- a/src/main/java/org/apache/commons/collections4/iterators/AbstractIteratorDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractIteratorDecorator.java
@@ -33,7 +33,7 @@ public abstract class AbstractIteratorDecorator<E> extends AbstractUntypedIterat
      * Constructor that decorates the specified iterator.
      *
      * @param iterator  the iterator to decorate, must not be null
-     * @throws NullPointerException if the iterator is null
+     * @throws IllegalArgumentException if the collection is null
      */
     protected AbstractIteratorDecorator(final Iterator<E> iterator) {
         super(iterator);
diff --git a/src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java b/src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java
index f380383c..eb33a227 100644
--- a/src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java
@@ -36,12 +36,12 @@ public class AbstractListIteratorDecorator<E> implements ListIterator<E> {
      * Constructor that decorates the specified iterator.
      *
      * @param iterator  the iterator to decorate, must not be null
-     * @throws NullPointerException if the iterator is null
+     * @throws IllegalArgumentException if the collection is null
      */
     public AbstractListIteratorDecorator(final ListIterator<E> iterator) {
         super();
         if (iterator == null) {
-            throw new NullPointerException("ListIterator must not be null");
+            throw new IllegalArgumentException("ListIterator must not be null");
         }
         this.iterator = iterator;
     }
diff --git a/src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java b/src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java
index 34d23f93..87d0c04f 100644
--- a/src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java
@@ -36,12 +36,12 @@ public class AbstractMapIteratorDecorator<K, V> implements MapIterator<K, V> {
      * Constructor that decorates the specified iterator.
      *
      * @param iterator  the iterator to decorate, must not be null
-     * @throws NullPointerException if the iterator is null
+     * @throws IllegalArgumentException if the collection is null
      */
     public AbstractMapIteratorDecorator(final MapIterator<K, V> iterator) {
         super();
         if (iterator == null) {
-            throw new NullPointerException("MapIterator must not be null");
+            throw new IllegalArgumentException("MapIterator must not be null");
         }
         this.iterator = iterator;
     }
diff --git a/src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java b/src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java
index 2118b8ec..71e35024 100644
--- a/src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java
@@ -36,12 +36,12 @@ public class AbstractOrderedMapIteratorDecorator<K, V> implements OrderedMapIter
      * Constructor that decorates the specified iterator.
      *
      * @param iterator  the iterator to decorate, must not be null
-     * @throws NullPointerException if the iterator is null
+     * @throws IllegalArgumentException if the collection is null
      */
     public AbstractOrderedMapIteratorDecorator(final OrderedMapIterator<K, V> iterator) {
         super();
         if (iterator == null) {
-            throw new NullPointerException("OrderedMapIterator must not be null");
+            throw new IllegalArgumentException("OrderedMapIterator must not be null");
         }
         this.iterator = iterator;
     }
diff --git a/src/main/java/org/apache/commons/collections4/iterators/AbstractUntypedIteratorDecorator.java b/src/main/java/org/apache/commons/collections4/iterators/AbstractUntypedIteratorDecorator.java
index 250bf2ac..3ea74ee0 100644
--- a/src/main/java/org/apache/commons/collections4/iterators/AbstractUntypedIteratorDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractUntypedIteratorDecorator.java
@@ -36,12 +36,11 @@ public abstract class AbstractUntypedIteratorDecorator<I, O> implements Iterator
      * Create a new AbstractUntypedIteratorDecorator.
      *
      * @param iterator  the iterator to decorate
-     * @throws NullPointerException if the iterator is null
      */
     protected AbstractUntypedIteratorDecorator(final Iterator<I> iterator) {
         super();
         if (iterator == null) {
-            throw new NullPointerException("Iterator must not be null");
+            throw new IllegalArgumentException("Iterator must not be null");
         }
         this.iterator = iterator;
     }
diff --git a/src/main/java/org/apache/commons/collections4/iterators/BoundedIterator.java b/src/main/java/org/apache/commons/collections4/iterators/BoundedIterator.java
index 8a5025cc..cb4d7fd1 100644
--- a/src/main/java/org/apache/commons/collections4/iterators/BoundedIterator.java
+++ b/src/main/java/org/apache/commons/collections4/iterators/BoundedIterator.java
@@ -57,12 +57,11 @@ public class BoundedIterator<E> implements Iterator<E> {
      * @param iterator  the iterator to be decorated
      * @param offset  the index of the first element of the decorated iterator to return
      * @param max  the maximum number of elements of the decorated iterator to return
-     * @throws NullPointerException if iterator is null
-     * @throws IllegalArgumentException if either offset or max is negative
+     * @throws IllegalArgumentException if iterator is null, or either offset or max is negative
      */
     public BoundedIterator(final Iterator<? extends E> iterator, final long offset, final long max) {
         if (iterator == null) {
-            throw new NullPointerException("Iterator must not be null");
+            throw new IllegalArgumentException("Iterator must not be null");
         }
         if (offset < 0) {
             throw new IllegalArgumentException("Offset parameter must not be negative.");
diff --git a/src/main/java/org/apache/commons/collections4/iterators/NodeListIterator.java b/src/main/java/org/apache/commons/collections4/iterators/NodeListIterator.java
index d88ce0dd..b8b0777e 100644
--- a/src/main/java/org/apache/commons/collections4/iterators/NodeListIterator.java
+++ b/src/main/java/org/apache/commons/collections4/iterators/NodeListIterator.java
@@ -17,7 +17,6 @@ package org.apache.commons.collections4.iterators;
 
 import java.util.Iterator;
 import java.util.NoSuchElementException;
-
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 
@@ -43,11 +42,11 @@ public class NodeListIterator implements Iterator<Node> {
      * the specified node's childNodes.
      *
      * @param node Node, who's child nodes are wrapped by this class. Must not be null
-     * @throws NullPointerException if node is null
+     * @throws IllegalArgumentException if node is null
      */
     public NodeListIterator(final Node node) {
         if (node == null) {
-            throw new NullPointerException("Node must not be null.");
+            throw new IllegalArgumentException("node must not be null!");
         }
         this.nodeList = node.getChildNodes();
     }
@@ -57,11 +56,11 @@ public class NodeListIterator implements Iterator<Node> {
      * <code>org.w3c.NodeList</code>
      *
      * @param nodeList node list, which is wrapped by this class. Must not be null
-     * @throws NullPointerException if nodeList is null
+     * @throws IllegalArgumentException if nodeList is null
      */
     public NodeListIterator(final NodeList nodeList) {
         if (nodeList == null) {
-            throw new NullPointerException("NodeList must not be null.");
+            throw new IllegalArgumentException("nodeList must not be null!");
         }
         this.nodeList = nodeList;
     }
diff --git a/src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java b/src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java
index 7ccb96a8..fb4cf92c 100644
--- a/src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java
+++ b/src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java
@@ -53,11 +53,11 @@ public class PeekingIterator<E> implements Iterator<E> {
      * @param <E>  the element type
      * @param iterator  the iterator to decorate
      * @return a new peeking iterator
-     * @throws NullPointerException if the iterator is null
+     * @throws IllegalArgumentException if the iterator is null
      */
     public static <E> PeekingIterator<E> peekingIterator(final Iterator<? extends E> iterator) {
         if (iterator == null) {
-            throw new NullPointerException("Iterator must not be null");
+            throw new IllegalArgumentException("Iterator must not be null");
         }
         if (iterator instanceof PeekingIterator<?>) {
             @SuppressWarnings("unchecked") // safe cast
diff --git a/src/main/java/org/apache/commons/collections4/iterators/PushbackIterator.java b/src/main/java/org/apache/commons/collections4/iterators/PushbackIterator.java
index 10390149..c805f875 100644
--- a/src/main/java/org/apache/commons/collections4/iterators/PushbackIterator.java
+++ b/src/main/java/org/apache/commons/collections4/iterators/PushbackIterator.java
@@ -50,11 +50,11 @@ public class PushbackIterator<E> implements Iterator<E> {
      * @param <E>  the element type
      * @param iterator  the iterator to decorate
      * @return a new peeking iterator
-     * @throws NullPointerException if the iterator is null
+     * @throws IllegalArgumentException if the iterator is null
      */
     public static <E> PushbackIterator<E> pushbackIterator(final Iterator<? extends E> iterator) {
         if (iterator == null) {
-            throw new NullPointerException("Iterator must not be null");
+            throw new IllegalArgumentException("Iterator must not be null");
         }
         if (iterator instanceof PushbackIterator<?>) {
             @SuppressWarnings("unchecked") // safe cast
diff --git a/src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java b/src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java
index e4529e9c..cf7b0d4d 100644
--- a/src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java
+++ b/src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java
@@ -53,9 +53,6 @@ public class ReverseListIterator<E> implements ResettableListIterator<E> {
      */
     public ReverseListIterator(final List<E> list) {
         super();
-        if (list == null) {
-            throw new NullPointerException("List must not be null.");
-        }
         this.list = list;
         iterator = list.listIterator(list.size());
     }
diff --git a/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java
index d6d566d6..48475c7e 100644
--- a/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java
+++ b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java
@@ -42,11 +42,11 @@ public final class UnmodifiableIterator<E> implements Iterator<E>, Unmodifiable
      * @param <E>  the element type
      * @param iterator  the iterator to decorate
      * @return a new unmodifiable iterator
-     * @throws NullPointerException if the iterator is null
+     * @throws IllegalArgumentException if the iterator is null
      */
     public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator) {
         if (iterator == null) {
-            throw new NullPointerException("Iterator must not be null");
+            throw new IllegalArgumentException("Iterator must not be null");
         }
         if (iterator instanceof Unmodifiable) {
             @SuppressWarnings("unchecked") // safe to upcast
diff --git a/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java
index 7e335957..6cc8e3fb 100644
--- a/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java
+++ b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java
@@ -40,11 +40,11 @@ public final class UnmodifiableListIterator<E> implements ListIterator<E>, Unmod
      * @param <E>  the element type
      * @param iterator  the iterator to decorate
      * @return a new unmodifiable list iterator
-     * @throws NullPointerException if the iterator is null
+     * @throws IllegalArgumentException if the iterator is null
      */
     public static <E> ListIterator<E> umodifiableListIterator(final ListIterator<? extends E> iterator) {
         if (iterator == null) {
-            throw new NullPointerException("ListIterator must not be null");
+            throw new IllegalArgumentException("ListIterator must not be null");
         }
         if (iterator instanceof Unmodifiable) {
             @SuppressWarnings("unchecked") // safe to upcast
diff --git a/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java
index 659c9b14..0d16443f 100644
--- a/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java
+++ b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java
@@ -40,12 +40,12 @@ public final class UnmodifiableMapIterator<K, V> implements MapIterator<K, V>, U
      * @param <V>  the value type
      * @param iterator  the iterator to decorate
      * @return a new unmodifiable map iterator
-     * @throws NullPointerException if the iterator is null
+     * @throws IllegalArgumentException if the iterator is null
      */
     public static <K, V> MapIterator<K, V> unmodifiableMapIterator(
             final MapIterator<? extends K, ? extends V> iterator) {
         if (iterator == null) {
-            throw new NullPointerException("MapIterator must not be null");
+            throw new IllegalArgumentException("MapIterator must not be null");
         }
         if (iterator instanceof Unmodifiable) {
             @SuppressWarnings("unchecked") // safe to upcast
diff --git a/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java
index 263a53b4..3a5038c5 100644
--- a/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java
+++ b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java
@@ -41,13 +41,13 @@ public final class UnmodifiableOrderedMapIterator<K, V> implements OrderedMapIte
      * @param <V>  the value type
      * @param iterator  the iterator to decorate
      * @return a new unmodifiable ordered map iterator
-     * @throws NullPointerException if the iterator is null
+     * @throws IllegalArgumentException if the iterator is null
      */
     public static <K, V> OrderedMapIterator<K, V> unmodifiableOrderedMapIterator(
             final OrderedMapIterator<K, ? extends V> iterator) {
 
         if (iterator == null) {
-            throw new NullPointerException("OrderedMapIterator must not be null");
+            throw new IllegalArgumentException("OrderedMapIterator must not be null");
         }
         if (iterator instanceof Unmodifiable) {
             @SuppressWarnings("unchecked") // safe to upcast
diff --git a/src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java b/src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java
index 72ee5ace..8733e033 100644
--- a/src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java
@@ -36,11 +36,11 @@ public abstract class AbstractMapEntryDecorator<K, V> implements Map.Entry<K, V>
      * Constructor that wraps (not copies).
      *
      * @param entry  the <code>Map.Entry</code> to decorate, must not be null
-     * @throws NullPointerException if the collection is null
+     * @throws IllegalArgumentException if the collection is null
      */
     public AbstractMapEntryDecorator(final Map.Entry<K, V> entry) {
         if (entry == null) {
-            throw new NullPointerException("Map Entry must not be null.");
+            throw new IllegalArgumentException("Map Entry must not be null");
         }
         this.entry = entry;
     }
diff --git a/src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java b/src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java
index be240545..67b89287 100644
--- a/src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java
@@ -49,7 +49,7 @@ public abstract class AbstractListDecorator<E> extends AbstractCollectionDecorat
      * Constructor that wraps (not copies).
      *
      * @param list  the list to decorate, must not be null
-     * @throws NullPointerException if list is null
+     * @throws IllegalArgumentException if list is null
      */
     protected AbstractListDecorator(final List<E> list) {
         super(list);
diff --git a/src/main/java/org/apache/commons/collections4/list/AbstractSerializableListDecorator.java b/src/main/java/org/apache/commons/collections4/list/AbstractSerializableListDecorator.java
index 2afd8bb1..13223796 100644
--- a/src/main/java/org/apache/commons/collections4/list/AbstractSerializableListDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/list/AbstractSerializableListDecorator.java
@@ -38,7 +38,7 @@ public abstract class AbstractSerializableListDecorator<E>
      * Constructor that wraps (not copies).
      *
      * @param list  the list to decorate, must not be null
-     * @throws NullPointerException if list is null
+     * @throws IllegalArgumentException if list is null
      */
     protected AbstractSerializableListDecorator(final List<E> list) {
         super(list);
diff --git a/src/main/java/org/apache/commons/collections4/list/FixedSizeList.java b/src/main/java/org/apache/commons/collections4/list/FixedSizeList.java
index 33ee16ce..dd16d259 100644
--- a/src/main/java/org/apache/commons/collections4/list/FixedSizeList.java
+++ b/src/main/java/org/apache/commons/collections4/list/FixedSizeList.java
@@ -49,7 +49,7 @@ public class FixedSizeList<E>
      * @param <E> the type of the elements in the list
      * @param list  the list to decorate, must not be null
      * @return a new fixed size list
-     * @throws NullPointerException if list is null
+     * @throws IllegalArgumentException if list is null
      * @since 4.0
      */
     public static <E> FixedSizeList<E> fixedSizeList(final List<E> list) {
@@ -61,7 +61,7 @@ public class FixedSizeList<E>
      * Constructor that wraps (not copies).
      *
      * @param list  the list to decorate, must not be null
-     * @throws NullPointerException if list is null
+     * @throws IllegalArgumentException if list is null
      */
     protected FixedSizeList(final List<E> list) {
         super(list);
diff --git a/src/main/java/org/apache/commons/collections4/list/GrowthList.java b/src/main/java/org/apache/commons/collections4/list/GrowthList.java
index a809d7f5..331f7026 100644
--- a/src/main/java/org/apache/commons/collections4/list/GrowthList.java
+++ b/src/main/java/org/apache/commons/collections4/list/GrowthList.java
@@ -63,7 +63,7 @@ public class GrowthList<E> extends AbstractSerializableListDecorator<E> {
      * @param <E> the type of the elements in the list
      * @param list  the list to decorate, must not be null
      * @return a new growth list
-     * @throws NullPointerException if list is null
+     * @throws IllegalArgumentException if list is null
      * @since 4.0
      */
     public static <E> GrowthList<E> growthList(final List<E> list) {
@@ -92,7 +92,7 @@ public class GrowthList<E> extends AbstractSerializableListDecorator<E> {
      * Constructor that wraps (not copies).
      *
      * @param list  the list to decorate, must not be null
-     * @throws NullPointerException if list is null
+     * @throws IllegalArgumentException if list is null
      */
     protected GrowthList(final List<E> list) {
         super(list);
diff --git a/src/main/java/org/apache/commons/collections4/list/LazyList.java b/src/main/java/org/apache/commons/collections4/list/LazyList.java
index 14324619..608771f5 100644
--- a/src/main/java/org/apache/commons/collections4/list/LazyList.java
+++ b/src/main/java/org/apache/commons/collections4/list/LazyList.java
@@ -72,7 +72,7 @@ public class LazyList<E> extends AbstractSerializableListDecorator<E> {
      * @param list  the list to decorate, must not be null
      * @param factory  the factory to use for creation, must not be null
      * @return a new lazy list
-     * @throws NullPointerException if list or factory is null
+     * @throws IllegalArgumentException if list or factory is null
      * @since 4.0
      */
     public static <E> LazyList<E> lazyList(final List<E> list, final Factory<? extends E> factory) {
@@ -85,7 +85,7 @@ public class LazyList<E> extends AbstractSerializableListDecorator<E> {
      *
      * @param list  the list to decorate, must not be null
      * @param factory  the factory to use for creation, must not be null
-     * @throws NullPointerException if list or factory is null
+     * @throws IllegalArgumentException if list or factory is null
      */
     protected LazyList(final List<E> list, final Factory<? extends E> factory) {
         super(list);
diff --git a/src/main/java/org/apache/commons/collections4/list/PredicatedList.java b/src/main/java/org/apache/commons/collections4/list/PredicatedList.java
index b158fdc5..5d51b600 100644
--- a/src/main/java/org/apache/commons/collections4/list/PredicatedList.java
+++ b/src/main/java/org/apache/commons/collections4/list/PredicatedList.java
@@ -60,7 +60,7 @@ public class PredicatedList<E> extends PredicatedCollection<E> implements List<E
      * @param list  the list to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
      * @return a new predicated list
-     * @throws NullPointerException if list or predicate is null
+     * @throws IllegalArgumentException if list or predicate is null
      * @throws IllegalArgumentException if the list contains invalid elements
      * @since 4.0
      */
@@ -77,7 +77,7 @@ public class PredicatedList<E> extends PredicatedCollection<E> implements List<E
      *
      * @param list  the list to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
-     * @throws NullPointerException if list or predicate is null
+     * @throws IllegalArgumentException if list or predicate is null
      * @throws IllegalArgumentException if the list contains invalid elements
      */
     protected PredicatedList(final List<E> list, final Predicate<? super E> predicate) {
diff --git a/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java b/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java
index ac4c6aab..26d2f7cb 100644
--- a/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java
+++ b/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java
@@ -65,12 +65,12 @@ public class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {
      * @param <E>  the element type
      * @param list  the list to decorate, must not be null
      * @return a new {@link SetUniqueList}
-     * @throws NullPointerException if list is null
+     * @throws IllegalArgumentException if list is null
      * @since 4.0
      */
     public static <E> SetUniqueList<E> setUniqueList(final List<E> list) {
         if (list == null) {
-            throw new NullPointerException("List must not be null");
+            throw new IllegalArgumentException("List must not be null");
         }
         if (list.isEmpty()) {
             return new SetUniqueList<E>(list, new HashSet<E>());
@@ -90,12 +90,12 @@ public class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {
      *
      * @param set  the set to decorate, must not be null
      * @param list  the list to decorate, must not be null
-     * @throws NullPointerException if set or list is null
+     * @throws IllegalArgumentException if set or list is null
      */
     protected SetUniqueList(final List<E> list, final Set<E> set) {
         super(list);
         if (set == null) {
-            throw new NullPointerException("Set must not be null");
+            throw new IllegalArgumentException("Set must not be null");
         }
         this.set = set;
     }
diff --git a/src/main/java/org/apache/commons/collections4/list/TransformedList.java b/src/main/java/org/apache/commons/collections4/list/TransformedList.java
index 968368c8..6a0ce29a 100644
--- a/src/main/java/org/apache/commons/collections4/list/TransformedList.java
+++ b/src/main/java/org/apache/commons/collections4/list/TransformedList.java
@@ -53,7 +53,7 @@ public class TransformedList<E> extends TransformedCollection<E> implements List
      * @param list  the list to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed list
-     * @throws NullPointerException if list or transformer is null
+     * @throws IllegalArgumentException if list or transformer is null
      * @since 4.0
      */
     public static <E> TransformedList<E> transformingList(final List<E> list,
@@ -73,13 +73,13 @@ public class TransformedList<E> extends TransformedCollection<E> implements List
      * @param list  the list to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed List
-     * @throws NullPointerException if list or transformer is null
+     * @throws IllegalArgumentException if list or transformer is null
      * @since 4.0
      */
     public static <E> TransformedList<E> transformedList(final List<E> list,
                                                          final Transformer<? super E, ? extends E> transformer) {
         final TransformedList<E> decorated = new TransformedList<E>(list, transformer);
-        if (list.size() > 0) {
+        if (transformer != null && list != null && list.size() > 0) {
             @SuppressWarnings("unchecked") // list is of type E
             final E[] values = (E[]) list.toArray(); // NOPMD - false positive for generics
             list.clear();
@@ -99,7 +99,7 @@ public class TransformedList<E> extends TransformedCollection<E> implements List
      *
      * @param list  the list to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
-     * @throws NullPointerException if list or transformer is null
+     * @throws IllegalArgumentException if list or transformer is null
      */
     protected TransformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {
         super(list, transformer);
diff --git a/src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java b/src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java
index 30fbb14d..27444cbb 100644
--- a/src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java
+++ b/src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java
@@ -48,7 +48,7 @@ public final class UnmodifiableList<E>
      * @param <E> the type of the elements in the list
      * @param list  the list to decorate, must not be null
      * @return a new unmodifiable list
-     * @throws NullPointerException if list is null
+     * @throws IllegalArgumentException if list is null
      * @since 4.0
      */
     public static <E> List<E> unmodifiableList(final List<? extends E> list) {
@@ -65,7 +65,7 @@ public final class UnmodifiableList<E>
      * Constructor that wraps (not copies).
      *
      * @param list  the list to decorate, must not be null
-     * @throws NullPointerException if list is null
+     * @throws IllegalArgumentException if list is null
      */
     @SuppressWarnings("unchecked") // safe to upcast
     public UnmodifiableList(final List<? extends E> list) {
diff --git a/src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java b/src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java
index a2b1959b..bd9f0517 100644
--- a/src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java
@@ -21,9 +21,9 @@ import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
+import org.apache.commons.collections4.set.AbstractSetDecorator;
 import org.apache.commons.collections4.iterators.AbstractIteratorDecorator;
 import org.apache.commons.collections4.keyvalue.AbstractMapEntryDecorator;
-import org.apache.commons.collections4.set.AbstractSetDecorator;
 
 /**
  * An abstract base class that simplifies the task of creating map decorators.
@@ -56,7 +56,7 @@ abstract class AbstractInputCheckedMapDecorator<K, V>
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      */
     protected AbstractInputCheckedMapDecorator(final Map<K, V> map) {
         super(map);
diff --git a/src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java b/src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java
index d718370c..ddf94549 100644
--- a/src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java
@@ -55,11 +55,11 @@ public abstract class AbstractMapDecorator<K, V> extends AbstractIterableMap<K,
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if the map is null
+     * @throws IllegalArgumentException if the collection is null
      */
     protected AbstractMapDecorator(final Map<K, V> map) {
         if (map == null) {
-            throw new NullPointerException("Map must not be null.");
+            throw new IllegalArgumentException("Map must not be null");
         }
         this.map = map;
     }
diff --git a/src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java b/src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java
index f4d2eb43..1cc5bb7d 100644
--- a/src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java
@@ -49,7 +49,7 @@ public abstract class AbstractOrderedMapDecorator<K, V> extends AbstractMapDecor
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if the map is null
+     * @throws IllegalArgumentException if the collection is null
      */
     public AbstractOrderedMapDecorator(final OrderedMap<K, V> map) {
         super(map);
diff --git a/src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java b/src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java
index c867db1a..c3c55939 100644
--- a/src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java
@@ -59,7 +59,7 @@ public abstract class AbstractSortedMapDecorator<K, V> extends AbstractMapDecora
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if the map is null
+     * @throws IllegalArgumentException if the collection is null
      */
     public AbstractSortedMapDecorator(final SortedMap<K, V> map) {
         super(map);
diff --git a/src/main/java/org/apache/commons/collections4/map/DefaultedMap.java b/src/main/java/org/apache/commons/collections4/map/DefaultedMap.java
index 17605fd3..369f918e 100644
--- a/src/main/java/org/apache/commons/collections4/map/DefaultedMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/DefaultedMap.java
@@ -80,7 +80,7 @@ public class DefaultedMap<K, V> extends AbstractMapDecorator<K, V> implements Se
      * @param map  the map to decorate, must not be null
      * @param defaultValue  the default value to return when the key is not found
      * @return a new defaulting map
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      * @since 4.0
      */
     public static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final V defaultValue) {
@@ -98,7 +98,7 @@ public class DefaultedMap<K, V> extends AbstractMapDecorator<K, V> implements Se
      * @param map  the map to decorate, must not be null
      * @param factory  the factory to use to create entries, must not be null
      * @return a new defaulting map
-     * @throws NullPointerException if map or factory is null
+     * @throws IllegalArgumentException if map or factory is null
      * @since 4.0
      */
     public static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final Factory<? extends V> factory) {
@@ -120,7 +120,7 @@ public class DefaultedMap<K, V> extends AbstractMapDecorator<K, V> implements Se
      * @param map  the map to decorate, must not be null
      * @param transformer  the transformer to use as a factory to create entries, must not be null
      * @return a new defaulting map
-     * @throws NullPointerException if map or factory is null
+     * @throws IllegalArgumentException if map or factory is null
      * @since 4.0
      */
     public static <K, V> Map<K, V> defaultedMap(final Map<K, V> map,
@@ -159,12 +159,12 @@ public class DefaultedMap<K, V> extends AbstractMapDecorator<K, V> implements Se
      *
      * @param map  the map to decorate, must not be null
      * @param defaultValueTransformer  the value transformer to use
-     * @throws NullPointerException if map or transformer is null
+     * @throws IllegalArgumentException if map or transformer is null
      */
     protected DefaultedMap(final Map<K, V> map, final Transformer<? super K, ? extends V> defaultValueTransformer) {
         super(map);
         if (defaultValueTransformer == null) {
-            throw new NullPointerException("Transformer must not be null.");
+            throw new IllegalArgumentException("transformer must not be null");
         }
         this.value = defaultValueTransformer;
     }
diff --git a/src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java b/src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java
index 29e35c26..70b6d595 100644
--- a/src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java
@@ -24,9 +24,9 @@ import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
 
+import org.apache.commons.collections4.set.UnmodifiableSet;
 import org.apache.commons.collections4.BoundedMap;
 import org.apache.commons.collections4.collection.UnmodifiableCollection;
-import org.apache.commons.collections4.set.UnmodifiableSet;
 
 /**
  * Decorates another <code>Map</code> to fix the size, preventing add/remove.
@@ -66,7 +66,7 @@ public class FixedSizeMap<K, V>
      * @param <V>  the value type
      * @param map  the map to decorate, must not be null
      * @return a new fixed size map
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      * @since 4.0
      */
     public static <K, V> FixedSizeMap<K, V> fixedSizeMap(final Map<K, V> map) {
@@ -78,7 +78,7 @@ public class FixedSizeMap<K, V>
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      */
     protected FixedSizeMap(final Map<K, V> map) {
         super(map);
diff --git a/src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java b/src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java
index 4a9deaad..c1a4dea8 100644
--- a/src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java
@@ -25,10 +25,10 @@ import java.util.Map;
 import java.util.Set;
 import java.util.SortedMap;
 
+import org.apache.commons.collections4.set.UnmodifiableSet;
 import org.apache.commons.collections4.BoundedMap;
 import org.apache.commons.collections4.CollectionUtils;
 import org.apache.commons.collections4.collection.UnmodifiableCollection;
-import org.apache.commons.collections4.set.UnmodifiableSet;
 
 /**
  * Decorates another <code>SortedMap</code> to fix the size blocking add/remove.
@@ -68,7 +68,7 @@ public class FixedSizeSortedMap<K, V>
      * @param <V>  the value type
      * @param map  the map to decorate, must not be null
      * @return a new fixed size sorted map
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      * @since 4.0
      */
     public static <K, V> FixedSizeSortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {
@@ -80,7 +80,7 @@ public class FixedSizeSortedMap<K, V>
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      */
     protected FixedSizeSortedMap(final SortedMap<K, V> map) {
         super(map);
diff --git a/src/main/java/org/apache/commons/collections4/map/LazyMap.java b/src/main/java/org/apache/commons/collections4/map/LazyMap.java
index ba857bca..25a5b1e2 100644
--- a/src/main/java/org/apache/commons/collections4/map/LazyMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/LazyMap.java
@@ -75,7 +75,7 @@ public class LazyMap<K, V> extends AbstractMapDecorator<K, V> implements Seriali
      * @param map  the map to decorate, must not be null
      * @param factory  the factory to use, must not be null
      * @return a new lazy map
-     * @throws NullPointerException if map or factory is null
+     * @throws IllegalArgumentException if map or factory is null
      * @since 4.0
      */
     public static <K, V> LazyMap<K, V> lazyMap(final Map<K, V> map, final Factory< ? extends V> factory) {
@@ -90,7 +90,7 @@ public class LazyMap<K, V> extends AbstractMapDecorator<K, V> implements Seriali
      * @param map  the map to decorate, must not be null
      * @param factory  the factory to use, must not be null
      * @return a new lazy map
-     * @throws NullPointerException if map or factory is null
+     * @throws IllegalArgumentException if map or factory is null
      * @since 4.0
      */
     public static <V, K> LazyMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> factory) {
@@ -103,12 +103,12 @@ public class LazyMap<K, V> extends AbstractMapDecorator<K, V> implements Seriali
      *
      * @param map  the map to decorate, must not be null
      * @param factory  the factory to use, must not be null
-     * @throws NullPointerException if map or factory is null
+     * @throws IllegalArgumentException if map or factory is null
      */
     protected LazyMap(final Map<K,V> map, final Factory<? extends V> factory) {
         super(map);
         if (factory == null) {
-            throw new NullPointerException("Factory must not be null");
+            throw new IllegalArgumentException("Factory must not be null");
         }
         this.factory = FactoryTransformer.factoryTransformer(factory);
     }
@@ -118,12 +118,12 @@ public class LazyMap<K, V> extends AbstractMapDecorator<K, V> implements Seriali
      *
      * @param map  the map to decorate, must not be null
      * @param factory  the factory to use, must not be null
-     * @throws NullPointerException if map or factory is null
+     * @throws IllegalArgumentException if map or factory is null
      */
     protected LazyMap(final Map<K,V> map, final Transformer<? super K, ? extends V> factory) {
         super(map);
         if (factory == null) {
-            throw new NullPointerException("Factory must not be null");
+            throw new IllegalArgumentException("Factory must not be null");
         }
         this.factory = factory;
     }
diff --git a/src/main/java/org/apache/commons/collections4/map/LazySortedMap.java b/src/main/java/org/apache/commons/collections4/map/LazySortedMap.java
index 459f5863..099e3936 100644
--- a/src/main/java/org/apache/commons/collections4/map/LazySortedMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/LazySortedMap.java
@@ -69,7 +69,7 @@ public class LazySortedMap<K,V> extends LazyMap<K,V> implements SortedMap<K,V> {
      * @param map  the map to decorate, must not be null
      * @param factory  the factory to use, must not be null
      * @return a new lazy sorted map
-     * @throws NullPointerException if map or factory is null
+     * @throws IllegalArgumentException if map or factory is null
      * @since 4.0
      */
     public static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,
@@ -85,7 +85,7 @@ public class LazySortedMap<K,V> extends LazyMap<K,V> implements SortedMap<K,V> {
      * @param map  the map to decorate, must not be null
      * @param factory  the factory to use, must not be null
      * @return a new lazy sorted map
-     * @throws NullPointerException if map or factory is null
+     * @throws IllegalArgumentException if map or factory is null
      * @since 4.0
      */
     public static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,
@@ -99,7 +99,7 @@ public class LazySortedMap<K,V> extends LazyMap<K,V> implements SortedMap<K,V> {
      *
      * @param map  the map to decorate, must not be null
      * @param factory  the factory to use, must not be null
-     * @throws NullPointerException if map or factory is null
+     * @throws IllegalArgumentException if map or factory is null
      */
     protected LazySortedMap(final SortedMap<K,V> map, final Factory<? extends V> factory) {
         super(map, factory);
@@ -110,7 +110,7 @@ public class LazySortedMap<K,V> extends LazyMap<K,V> implements SortedMap<K,V> {
      *
      * @param map  the map to decorate, must not be null
      * @param factory  the factory to use, must not be null
-     * @throws NullPointerException if map or factory is null
+     * @throws IllegalArgumentException if map or factory is null
      */
     protected LazySortedMap(final SortedMap<K,V> map, final Transformer<? super K, ? extends V> factory) {
         super(map, factory);
diff --git a/src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java b/src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java
index 55c85f2f..37ef2f34 100644
--- a/src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java
@@ -94,7 +94,7 @@ public class ListOrderedMap<K, V>
      * @param <V>  the value type
      * @param map  the map to decorate, must not be null
      * @return a new list ordered map
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      * @since 4.0
      */
     public static <K, V> ListOrderedMap<K, V> listOrderedMap(final Map<K, V> map) {
@@ -116,7 +116,7 @@ public class ListOrderedMap<K, V>
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      */
     protected ListOrderedMap(final Map<K, V> map) {
         super(map);
diff --git a/src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java b/src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java
index ab3f830a..4c9a993e 100644
--- a/src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java
@@ -89,13 +89,12 @@ public class MultiKeyMap<K, V> extends AbstractMapDecorator<MultiKey<? extends K
      * @param <V>  the value type
      * @param map  the map to decorate, not null
      * @return a new multi key map
-     * @throws NullPointerException if map is null
-     * @throws IllegalArgumentException if the map is not empty
+     * @throws IllegalArgumentException if the map is null or not empty
      * @since 4.0
      */
     public static <K, V> MultiKeyMap<K, V> multiKeyMap(final AbstractHashedMap<MultiKey<? extends K>, V> map) {
         if (map == null) {
-            throw new NullPointerException("Map must not be null");
+            throw new IllegalArgumentException("Map must not be null");
         }
         if (map.size() > 0) {
             throw new IllegalArgumentException("Map must be empty");
diff --git a/src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java b/src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java
index f1564091..0034a7c3 100644
--- a/src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java
@@ -117,7 +117,7 @@ public class PassiveExpiringMap<K, V>
          *        expire.
          * @param timeUnit the unit of time for the <code>timeToLive</code>
          *        parameter, must not be null.
-         * @throws NullPointerException if the time unit is null.
+         * @throws IllegalArgumentException if the time unit is null.
          */
         public ConstantTimeToLiveExpirationPolicy(final long timeToLive,
                                                   final TimeUnit timeUnit) {
@@ -181,19 +181,20 @@ public class PassiveExpiringMap<K, V>
     /**
      * First validate the input parameters. If the parameters are valid, convert
      * the given time measured in the given units to the same time measured in
-     * milliseconds.
+     * milliseconds. If the parameters are invalid, an
+     * {@link IllegalArgumentException} is thrown.
      *
      * @param timeToLive the constant amount of time an entry is available
      *        before it expires. A negative value results in entries that NEVER
      *        expire. A zero value results in entries that ALWAYS expire.
      * @param timeUnit the unit of time for the <code>timeToLive</code>
      *        parameter, must not be null.
-     * @throws NullPointerException if the time unit is null.
+     * @throws IllegalArgumentException if the time unit is null.
      */
     private static long validateAndConvertToMillis(final long timeToLive,
                                                    final TimeUnit timeUnit) {
         if (timeUnit == null) {
-            throw new NullPointerException("Time unit must not be null");
+            throw new IllegalArgumentException("Time unit must not be null");
         }
         return TimeUnit.MILLISECONDS.convert(timeToLive, timeUnit);
     }
@@ -218,7 +219,6 @@ public class PassiveExpiringMap<K, V>
      *
      * @param expiringPolicy the policy used to determine expiration times of
      *        entries as they are added.
-     * @throws NullPointerException if expiringPolicy is null
      */
     public PassiveExpiringMap(final ExpirationPolicy<K, V> expiringPolicy) {
         this(expiringPolicy, new HashMap<K, V>());
@@ -233,13 +233,13 @@ public class PassiveExpiringMap<K, V>
      * @param expiringPolicy the policy used to determine expiration times of
      *        entries as they are added.
      * @param map the map to decorate, must not be null.
-     * @throws NullPointerException if the map or expiringPolicy is null.
+     * @throws IllegalArgumentException if the map is null.
      */
     public PassiveExpiringMap(final ExpirationPolicy<K, V> expiringPolicy,
                               final Map<K, V> map) {
         super(map);
         if (expiringPolicy == null) {
-            throw new NullPointerException("Policy must not be null.");
+            throw new IllegalArgumentException("Policy must not be null.");
         }
         this.expiringPolicy = expiringPolicy;
     }
@@ -271,7 +271,7 @@ public class PassiveExpiringMap<K, V>
      *        entries that NEVER expire. A zero value results in entries that
      *        ALWAYS expire.
      * @param map the map to decorate, must not be null.
-     * @throws NullPointerException if the map is null.
+     * @throws IllegalArgumentException if the map is null.
      */
     public PassiveExpiringMap(final long timeToLiveMillis, final Map<K, V> map) {
         this(new ConstantTimeToLiveExpirationPolicy<K, V>(timeToLiveMillis),
@@ -288,7 +288,7 @@ public class PassiveExpiringMap<K, V>
      *        expire. A zero value results in entries that ALWAYS expire.
      * @param timeUnit the unit of time for the <code>timeToLive</code>
      *        parameter, must not be null.
-     * @throws NullPointerException if the time unit is null.
+     * @throws IllegalArgumentException if the time unit is null.
      */
     public PassiveExpiringMap(final long timeToLive, final TimeUnit timeUnit) {
         this(validateAndConvertToMillis(timeToLive, timeUnit));
@@ -308,7 +308,8 @@ public class PassiveExpiringMap<K, V>
      * @param timeUnit the unit of time for the <code>timeToLive</code>
      *        parameter, must not be null.
      * @param map the map to decorate, must not be null.
-     * @throws NullPointerException if the map or time unit is null.
+     * @throws IllegalArgumentException if the time unit is null.
+     * @throws IllegalArgumentException if the map is null.
      */
     public PassiveExpiringMap(final long timeToLive, final TimeUnit timeUnit, final Map<K, V> map) {
         this(validateAndConvertToMillis(timeToLive, timeUnit), map);
@@ -320,7 +321,7 @@ public class PassiveExpiringMap<K, V>
      * being decorated, they also will NEVER expire.
      *
      * @param map the map to decorate, must not be null.
-     * @throws NullPointerException if the map is null.
+     * @throws IllegalArgumentException if the map is null.
      */
     public PassiveExpiringMap(final Map<K, V> map) {
         this(-1L, map);
diff --git a/src/main/java/org/apache/commons/collections4/map/PredicatedMap.java b/src/main/java/org/apache/commons/collections4/map/PredicatedMap.java
index d895fa75..2440420a 100644
--- a/src/main/java/org/apache/commons/collections4/map/PredicatedMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/PredicatedMap.java
@@ -72,7 +72,7 @@ public class PredicatedMap<K, V>
      * @param keyPredicate  the predicate to validate the keys, null means no check
      * @param valuePredicate  the predicate to validate to values, null means no check
      * @return a new predicated map
-     * @throws NullPointerException if the map is null
+     * @throws IllegalArgumentException if the map is null
      * @since 4.0
      */
     public static <K, V> PredicatedMap<K, V> predicatedMap(final Map<K, V> map,
@@ -88,7 +88,7 @@ public class PredicatedMap<K, V>
      * @param map  the map to decorate, must not be null
      * @param keyPredicate  the predicate to validate the keys, null means no check
      * @param valuePredicate  the predicate to validate to values, null means no check
-     * @throws NullPointerException if the map is null
+     * @throws IllegalArgumentException if the map is null
      */
     protected PredicatedMap(final Map<K, V> map, final Predicate<? super K> keyPredicate,
                             final Predicate<? super V> valuePredicate) {
diff --git a/src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java b/src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java
index aa109315..1f12b3d3 100644
--- a/src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java
@@ -65,7 +65,7 @@ public class PredicatedSortedMap<K, V> extends PredicatedMap<K, V> implements So
      * @param keyPredicate  the predicate to validate the keys, null means no check
      * @param valuePredicate  the predicate to validate to values, null means no check
      * @return a new predicated sorted map
-     * @throws NullPointerException if the map is null
+     * @throws IllegalArgumentException if the map is null
      * @since 4.0
      */
     public static <K, V> PredicatedSortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map,
@@ -80,7 +80,7 @@ public class PredicatedSortedMap<K, V> extends PredicatedMap<K, V> implements So
      * @param map  the map to decorate, must not be null
      * @param keyPredicate  the predicate to validate the keys, null means no check
      * @param valuePredicate  the predicate to validate to values, null means no check
-     * @throws NullPointerException if the map is null
+     * @throws IllegalArgumentException if the map is null
      */
     protected PredicatedSortedMap(final SortedMap<K, V> map, final Predicate<? super K> keyPredicate,
             final Predicate<? super V> valuePredicate) {
diff --git a/src/main/java/org/apache/commons/collections4/map/SingletonMap.java b/src/main/java/org/apache/commons/collections4/map/SingletonMap.java
index a3362fe2..75dbaafd 100644
--- a/src/main/java/org/apache/commons/collections4/map/SingletonMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/SingletonMap.java
@@ -43,7 +43,7 @@ import org.apache.commons.collections4.keyvalue.TiedMapEntry;
  * <p>
  * If trying to remove or clear the map, an UnsupportedOperationException is thrown.
  * If trying to put a new mapping into the map, an  IllegalArgumentException is thrown.
- * The put method will only succeed if the key specified is the same as the
+ * The put method will only suceed if the key specified is the same as the
  * singleton key.
  * <p>
  * The key and value can be obtained by:
diff --git a/src/main/java/org/apache/commons/collections4/map/TransformedMap.java b/src/main/java/org/apache/commons/collections4/map/TransformedMap.java
index 5b57bc64..c1244abc 100644
--- a/src/main/java/org/apache/commons/collections4/map/TransformedMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/TransformedMap.java
@@ -70,7 +70,7 @@ public class TransformedMap<K, V>
      * @param keyTransformer  the transformer to use for key conversion, null means no transformation
      * @param valueTransformer  the transformer to use for value conversion, null means no transformation
      * @return a new transformed map
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      * @since 4.0
      */
     public static <K, V> TransformedMap<K, V> transformingMap(final Map<K, V> map,
@@ -93,7 +93,7 @@ public class TransformedMap<K, V>
      * @param keyTransformer  the transformer to use for key conversion, null means no transformation
      * @param valueTransformer  the transformer to use for value conversion, null means no transformation
      * @return a new transformed map
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      * @since 4.0
      */
     public static <K, V> TransformedMap<K, V> transformedMap(final Map<K, V> map,
@@ -118,7 +118,7 @@ public class TransformedMap<K, V>
      * @param map  the map to decorate, must not be null
      * @param keyTransformer  the transformer to use for key conversion, null means no conversion
      * @param valueTransformer  the transformer to use for value conversion, null means no conversion
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      */
     protected TransformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer,
             final Transformer<? super V, ? extends V> valueTransformer) {
diff --git a/src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java b/src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java
index 6044d332..6254a4cd 100644
--- a/src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java
@@ -60,7 +60,7 @@ public class TransformedSortedMap<K, V>
      * @param keyTransformer  the predicate to validate the keys, null means no transformation
      * @param valueTransformer  the predicate to validate to values, null means no transformation
      * @return a new transformed sorted map
-     * @throws NullPointerException if the map is null
+     * @throws IllegalArgumentException if the map is null
      * @since 4.0
      */
     public static <K, V> TransformedSortedMap<K, V> transformingSortedMap(final SortedMap<K, V> map,
@@ -83,7 +83,7 @@ public class TransformedSortedMap<K, V>
      * @param keyTransformer  the transformer to use for key conversion, null means no transformation
      * @param valueTransformer  the transformer to use for value conversion, null means no transformation
      * @return a new transformed sorted map
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      * @since 4.0
      */
     public static <K, V> TransformedSortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map,
@@ -110,7 +110,7 @@ public class TransformedSortedMap<K, V>
      * @param map  the map to decorate, must not be null
      * @param keyTransformer  the predicate to validate the keys, null means no transformation
      * @param valueTransformer  the predicate to validate to values, null means no transformation
-     * @throws NullPointerException if the map is null
+     * @throws IllegalArgumentException if the map is null
      */
     protected TransformedSortedMap(final SortedMap<K, V> map,
             final Transformer<? super K, ? extends K> keyTransformer,
diff --git a/src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java b/src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java
index 99683f62..5d0d6530 100644
--- a/src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java
+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java
@@ -22,10 +22,10 @@ import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
+import org.apache.commons.collections4.set.AbstractSetDecorator;
 import org.apache.commons.collections4.Unmodifiable;
 import org.apache.commons.collections4.iterators.AbstractIteratorDecorator;
 import org.apache.commons.collections4.keyvalue.AbstractMapEntryDecorator;
-import org.apache.commons.collections4.set.AbstractSetDecorator;
 
 /**
  * Decorates a map entry <code>Set</code> to ensure it can't be altered.
@@ -48,7 +48,7 @@ public final class UnmodifiableEntrySet<K, V>
      * @param <V>  the value type
      * @param set  the set to decorate, must not be null
      * @return a new unmodifiable entry set
-     * @throws NullPointerException if set is null
+     * @throws IllegalArgumentException if set is null
      * @since 4.0
      */
     public static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(final Set<Map.Entry<K, V>> set) {
@@ -63,7 +63,7 @@ public final class UnmodifiableEntrySet<K, V>
      * Constructor that wraps (not copies).
      *
      * @param set  the set to decorate, must not be null
-     * @throws NullPointerException if set is null
+     * @throws IllegalArgumentException if set is null
      */
     private UnmodifiableEntrySet(final Set<Map.Entry<K, V>> set) {
         super(set);
diff --git a/src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java b/src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java
index c702363f..46853f69 100644
--- a/src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java
@@ -24,13 +24,13 @@ import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
 
+import org.apache.commons.collections4.set.UnmodifiableSet;
 import org.apache.commons.collections4.IterableMap;
 import org.apache.commons.collections4.MapIterator;
 import org.apache.commons.collections4.Unmodifiable;
 import org.apache.commons.collections4.collection.UnmodifiableCollection;
 import org.apache.commons.collections4.iterators.EntrySetMapIterator;
 import org.apache.commons.collections4.iterators.UnmodifiableMapIterator;
-import org.apache.commons.collections4.set.UnmodifiableSet;
 
 /**
  * Decorates another <code>Map</code> to ensure it can't be altered.
@@ -56,7 +56,7 @@ public final class UnmodifiableMap<K, V>
      * @param <V>  the value type
      * @param map  the map to decorate, must not be null
      * @return a new unmodifiable map
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      * @since 4.0
      */
     public static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {
@@ -73,7 +73,7 @@ public final class UnmodifiableMap<K, V>
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      */
     @SuppressWarnings("unchecked") // safe to upcast
     private UnmodifiableMap(final Map<? extends K, ? extends V> map) {
diff --git a/src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java b/src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java
index 848961ca..67ee8034 100644
--- a/src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java
@@ -24,12 +24,12 @@ import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
 
+import org.apache.commons.collections4.set.UnmodifiableSet;
 import org.apache.commons.collections4.OrderedMap;
 import org.apache.commons.collections4.OrderedMapIterator;
 import org.apache.commons.collections4.Unmodifiable;
 import org.apache.commons.collections4.collection.UnmodifiableCollection;
 import org.apache.commons.collections4.iterators.UnmodifiableOrderedMapIterator;
-import org.apache.commons.collections4.set.UnmodifiableSet;
 
 /**
  * Decorates another <code>OrderedMap</code> to ensure it can't be altered.
@@ -54,7 +54,7 @@ public final class UnmodifiableOrderedMap<K, V> extends AbstractOrderedMapDecora
      * @param <V>  the value type
      * @param map  the map to decorate, must not be null
      * @return a new ordered map
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      * @since 4.0
      */
     public static <K, V> OrderedMap<K, V> unmodifiableOrderedMap(final OrderedMap<? extends K, ? extends V> map) {
@@ -71,7 +71,7 @@ public final class UnmodifiableOrderedMap<K, V> extends AbstractOrderedMapDecora
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      */
     @SuppressWarnings("unchecked") // safe to upcast
     private UnmodifiableOrderedMap(final OrderedMap<? extends K, ? extends V> map) {
diff --git a/src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java b/src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java
index 683aba83..a72953e6 100644
--- a/src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java
+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java
@@ -26,9 +26,9 @@ import java.util.Map;
 import java.util.Set;
 import java.util.SortedMap;
 
+import org.apache.commons.collections4.set.UnmodifiableSet;
 import org.apache.commons.collections4.Unmodifiable;
 import org.apache.commons.collections4.collection.UnmodifiableCollection;
-import org.apache.commons.collections4.set.UnmodifiableSet;
 
 /**
  * Decorates another <code>SortedMap</code> to ensure it can't be altered.
@@ -54,7 +54,7 @@ public final class UnmodifiableSortedMap<K, V>
      * @param <V>  the value type
      * @param map  the map to decorate, must not be null
      * @return a new unmodifiable sorted map
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      * @since 4.0
      */
     public static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {
@@ -71,7 +71,7 @@ public final class UnmodifiableSortedMap<K, V>
      * Constructor that wraps (not copies).
      *
      * @param map  the map to decorate, must not be null
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      */
     @SuppressWarnings("unchecked") // safe to upcast
     private UnmodifiableSortedMap(final SortedMap<K, ? extends V> map) {
diff --git a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java
index 124e6859..1a9af4b2 100644
--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java
+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java
@@ -269,7 +269,6 @@ public abstract class AbstractMultiValuedMap<K, V> implements MultiValuedMap<K,
      * progress.
      *
      * @param map mappings to be stored in this map, may not be null
-     * @return true if the map changed as a result of this operation
      * @throws NullPointerException if map is null
      */
     @Override
@@ -293,7 +292,6 @@ public abstract class AbstractMultiValuedMap<K, V> implements MultiValuedMap<K,
      * while the operation is in progress.
      *
      * @param map mappings to be stored in this map, may not be null
-     * @return true if the map changed as a result of this operation
      * @throws NullPointerException if map is null
      */
     @Override
diff --git a/src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java b/src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java
index d504cb20..382ec9ea 100644
--- a/src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java
@@ -46,7 +46,7 @@ public abstract class AbstractMultiSetDecorator<E>
      * Constructor that wraps (not copies).
      *
      * @param multiset  the multiset to decorate, must not be null
-     * @throws NullPointerException if multiset is null
+     * @throws IllegalArgumentException if multiset is null
      */
     protected AbstractMultiSetDecorator(final MultiSet<E> multiset) {
         super(multiset);
diff --git a/src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java b/src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java
index a98dbbd2..eabee450 100644
--- a/src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java
@@ -52,7 +52,7 @@ public abstract class AbstractQueueDecorator<E> extends AbstractCollectionDecora
      * Constructor that wraps (not copies).
      *
      * @param queue  the queue to decorate, must not be null
-     * @throws NullPointerException if queue is null
+     * @throws IllegalArgumentException if list is null
      */
     protected AbstractQueueDecorator(final Queue<E> queue) {
         super(queue);
diff --git a/src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java b/src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java
index 3f35e874..4f98347f 100644
--- a/src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java
+++ b/src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java
@@ -50,7 +50,7 @@ public class PredicatedQueue<E> extends PredicatedCollection<E> implements Queue
      * @param Queue  the queue to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
      * @return a new predicated queue
-     * @throws NullPointerException if queue or predicate is null
+     * @throws IllegalArgumentException if queue or predicate is null
      * @throws IllegalArgumentException if the queue contains invalid elements
      */
     public static <E> PredicatedQueue<E> predicatedQueue(final Queue<E> Queue,
@@ -67,7 +67,7 @@ public class PredicatedQueue<E> extends PredicatedCollection<E> implements Queue
      *
      * @param queue  the queue to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
-     * @throws NullPointerException if queue or predicate is null
+     * @throws IllegalArgumentException if Queue or predicate is null
      * @throws IllegalArgumentException if the Queue contains invalid elements
      */
     protected PredicatedQueue(final Queue<E> queue, final Predicate<? super E> predicate) {
diff --git a/src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java b/src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java
index c314c053..9b2d672e 100644
--- a/src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java
+++ b/src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java
@@ -48,7 +48,7 @@ public class TransformedQueue<E> extends TransformedCollection<E> implements Que
      * @param queue  the queue to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed Queue
-     * @throws NullPointerException if queue or transformer is null
+     * @throws IllegalArgumentException if queue or transformer is null
      */
     public static <E> TransformedQueue<E> transformingQueue(final Queue<E> queue,
                                                             final Transformer<? super E, ? extends E> transformer) {
@@ -67,7 +67,7 @@ public class TransformedQueue<E> extends TransformedCollection<E> implements Que
      * @param queue  the queue to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed Queue
-     * @throws NullPointerException if queue or transformer is null
+     * @throws IllegalArgumentException if queue or transformer is null
      * @since 4.0
      */
     public static <E> TransformedQueue<E> transformedQueue(final Queue<E> queue,
@@ -94,7 +94,7 @@ public class TransformedQueue<E> extends TransformedCollection<E> implements Que
      *
      * @param queue  the queue to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
-     * @throws NullPointerException if queue or transformer is null
+     * @throws IllegalArgumentException if queue or transformer is null
      */
     protected TransformedQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {
         super(queue, transformer);
diff --git a/src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java b/src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java
index 05451c9b..3926f5df 100644
--- a/src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java
+++ b/src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java
@@ -49,7 +49,7 @@ public final class UnmodifiableQueue<E>
      * @param <E> the type of the elements in the queue
      * @param queue  the queue to decorate, must not be null
      * @return an unmodifiable Queue
-     * @throws NullPointerException if queue is null
+     * @throws IllegalArgumentException if queue is null
      */
     public static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {
         if (queue instanceof Unmodifiable) {
@@ -65,7 +65,7 @@ public final class UnmodifiableQueue<E>
      * Constructor that wraps (not copies).
      *
      * @param queue  the queue to decorate, must not be null
-     * @throws NullPointerException if queue is null
+     * @throws IllegalArgumentException if queue is null
      */
     @SuppressWarnings("unchecked") // safe to upcast
     private UnmodifiableQueue(final Queue<? extends E> queue) {
diff --git a/src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java b/src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java
index e4a337cc..a18371b2 100644
--- a/src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java
@@ -46,7 +46,7 @@ public abstract class AbstractNavigableSetDecorator<E>
      * Constructor that wraps (not copies).
      *
      * @param set  the set to decorate, must not be null
-     * @throws NullPointerException if set is null
+     * @throws IllegalArgumentException if set is null
      */
     protected AbstractNavigableSetDecorator(final NavigableSet<E> set) {
         super(set);
diff --git a/src/main/java/org/apache/commons/collections4/set/AbstractSerializableSetDecorator.java b/src/main/java/org/apache/commons/collections4/set/AbstractSerializableSetDecorator.java
index e8e74e37..b01c0071 100644
--- a/src/main/java/org/apache/commons/collections4/set/AbstractSerializableSetDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/set/AbstractSerializableSetDecorator.java
@@ -38,7 +38,7 @@ public abstract class AbstractSerializableSetDecorator<E>
      * Constructor.
      *
      * @param set  the list to decorate, must not be null
-     * @throws NullPointerException if set is null
+     * @throws IllegalArgumentException if set is null
      */
     protected AbstractSerializableSetDecorator(final Set<E> set) {
         super(set);
diff --git a/src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java b/src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java
index e616623e..1be4a123 100644
--- a/src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java
@@ -47,7 +47,7 @@ public abstract class AbstractSetDecorator<E> extends AbstractCollectionDecorato
      * Constructor that wraps (not copies).
      *
      * @param set  the set to decorate, must not be null
-     * @throws NullPointerException if set is null
+     * @throws IllegalArgumentException if set is null
      */
     protected AbstractSetDecorator(final Set<E> set) {
         super(set);
diff --git a/src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java b/src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java
index 44818ae4..5fbce965 100644
--- a/src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java
@@ -48,7 +48,7 @@ public abstract class AbstractSortedSetDecorator<E>
      * Constructor that wraps (not copies).
      *
      * @param set  the set to decorate, must not be null
-     * @throws NullPointerException if set is null
+     * @throws IllegalArgumentException if set is null
      */
     protected AbstractSortedSetDecorator(final Set<E> set) {
         super(set);
diff --git a/src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java b/src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java
index 14fe6c0e..cf59d574 100644
--- a/src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java
+++ b/src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java
@@ -70,16 +70,16 @@ public class ListOrderedSet<E>
      * @param set the set to decorate, must be empty and not null
      * @param list the list to decorate, must be empty and not null
      * @return a new ordered set
-     * @throws NullPointerException if set or list is null
+     * @throws IllegalArgumentException if set or list is null
      * @throws IllegalArgumentException if either the set or list is not empty
      * @since 4.0
      */
     public static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set, final List<E> list) {
         if (set == null) {
-            throw new NullPointerException("Set must not be null");
+            throw new IllegalArgumentException("Set must not be null");
         }
         if (list == null) {
-            throw new NullPointerException("List must not be null");
+            throw new IllegalArgumentException("List must not be null");
         }
         if (set.size() > 0 || list.size() > 0) {
             throw new IllegalArgumentException("Set and List must be empty");
@@ -95,7 +95,7 @@ public class ListOrderedSet<E>
      * @param <E> the element type
      * @param set the set to decorate, must not be null
      * @return a new ordered set
-     * @throws NullPointerException if set is null
+     * @throws IllegalArgumentException if set is null
      * @since 4.0
      */
     public static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set) {
@@ -113,12 +113,12 @@ public class ListOrderedSet<E>
      * @param <E> the element type
      * @param list the list to decorate, must not be null
      * @return a new ordered set
-     * @throws NullPointerException if list is null
+     * @throws IllegalArgumentException if list is null
      * @since 4.0
      */
     public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list) {
         if (list == null) {
-            throw new NullPointerException("List must not be null");
+            throw new IllegalArgumentException("List must not be null");
         }
         CollectionUtils.filter(list, UniquePredicate.uniquePredicate());
         final Set<E> set = new HashSet<E>(list);
@@ -157,12 +157,12 @@ public class ListOrderedSet<E>
      *
      * @param set the set to decorate, must not be null
      * @param list the list to decorate, must not be null
-     * @throws NullPointerException if set or list is null
+     * @throws IllegalArgumentException if set or list is null
      */
     protected ListOrderedSet(final Set<E> set, final List<E> list) {
         super(set);
         if (list == null) {
-            throw new NullPointerException("List must not be null");
+            throw new IllegalArgumentException("List must not be null");
         }
         setOrder = list;
     }
diff --git a/src/main/java/org/apache/commons/collections4/set/MapBackedSet.java b/src/main/java/org/apache/commons/collections4/set/MapBackedSet.java
index f1a4f130..601a6d28 100644
--- a/src/main/java/org/apache/commons/collections4/set/MapBackedSet.java
+++ b/src/main/java/org/apache/commons/collections4/set/MapBackedSet.java
@@ -53,7 +53,7 @@ public final class MapBackedSet<E, V> implements Set<E>, Serializable {
      * @param <V> the dummy value type in the map
      * @param map  the map to decorate, must not be null
      * @return a new map backed set
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if set is null
      * @since 4.0
      */
     public static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map) {
@@ -68,10 +68,13 @@ public final class MapBackedSet<E, V> implements Set<E>, Serializable {
      * @param map  the map to decorate, must not be null
      * @param dummyValue  the dummy value to use
      * @return a new map backed set
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      * @since 4.0
      */
     public static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map, final V dummyValue) {
+        if (map == null) {
+            throw new IllegalArgumentException("The map must not be null");
+        }
         return new MapBackedSet<E, V>(map, dummyValue);
     }
 
@@ -81,13 +84,10 @@ public final class MapBackedSet<E, V> implements Set<E>, Serializable {
      *
      * @param map  the map to decorate, must not be null
      * @param dummyValue  the dummy value to use
-     * @throws NullPointerException if map is null
+     * @throws IllegalArgumentException if map is null
      */
     private MapBackedSet(final Map<E, ? super V> map, final V dummyValue) {
         super();
-        if (map == null) {
-            throw new NullPointerException("The map must not be null");
-        }
         this.map = map;
         this.dummyValue = dummyValue;
     }
diff --git a/src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java b/src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java
index 265c8c8b..c932a316 100644
--- a/src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java
+++ b/src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java
@@ -54,7 +54,7 @@ public class PredicatedNavigableSet<E> extends PredicatedSortedSet<E> implements
      * @param set  the set to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
      * @return a new predicated navigable set.
-     * @throws NullPointerException if set or predicate is null
+     * @throws IllegalArgumentException if set or predicate is null
      * @throws IllegalArgumentException if the set contains invalid elements
      * @since 4.0
      */
@@ -72,7 +72,7 @@ public class PredicatedNavigableSet<E> extends PredicatedSortedSet<E> implements
      *
      * @param set  the set to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
-     * @throws NullPointerException if set or predicate is null
+     * @throws IllegalArgumentException if set or predicate is null
      * @throws IllegalArgumentException if the set contains invalid elements
      */
     protected PredicatedNavigableSet(final NavigableSet<E> set, final Predicate<? super E> predicate) {
diff --git a/src/main/java/org/apache/commons/collections4/set/PredicatedSet.java b/src/main/java/org/apache/commons/collections4/set/PredicatedSet.java
index 6ad3c876..472a1317 100644
--- a/src/main/java/org/apache/commons/collections4/set/PredicatedSet.java
+++ b/src/main/java/org/apache/commons/collections4/set/PredicatedSet.java
@@ -52,7 +52,7 @@ public class PredicatedSet<E> extends PredicatedCollection<E> implements Set<E>
      * @param set  the set to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
      * @return a decorated set
-     * @throws NullPointerException if set or predicate is null
+     * @throws IllegalArgumentException if set or predicate is null
      * @throws IllegalArgumentException if the set contains invalid elements
      * @since 4.0
      */
@@ -69,7 +69,7 @@ public class PredicatedSet<E> extends PredicatedCollection<E> implements Set<E>
      *
      * @param set  the set to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
-     * @throws NullPointerException if set or predicate is null
+     * @throws IllegalArgumentException if set or predicate is null
      * @throws IllegalArgumentException if the set contains invalid elements
      */
     protected PredicatedSet(final Set<E> set, final Predicate<? super E> predicate) {
diff --git a/src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java b/src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java
index 0610a64b..85b00907 100644
--- a/src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java
+++ b/src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java
@@ -56,7 +56,7 @@ public class PredicatedSortedSet<E> extends PredicatedSet<E> implements SortedSe
      * @param set  the set to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
      * @return a new predicated sorted set.
-     * @throws NullPointerException if set or predicate is null
+     * @throws IllegalArgumentException if set or predicate is null
      * @throws IllegalArgumentException if the set contains invalid elements
      * @since 4.0
      */
@@ -74,7 +74,7 @@ public class PredicatedSortedSet<E> extends PredicatedSet<E> implements SortedSe
      *
      * @param set  the set to decorate, must not be null
      * @param predicate  the predicate to use for validation, must not be null
-     * @throws NullPointerException if set or predicate is null
+     * @throws IllegalArgumentException if set or predicate is null
      * @throws IllegalArgumentException if the set contains invalid elements
      */
     protected PredicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {
diff --git a/src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java b/src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java
index 9d431dc4..220527c7 100644
--- a/src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java
+++ b/src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java
@@ -48,7 +48,7 @@ public class TransformedNavigableSet<E> extends TransformedSortedSet<E> implemen
      * @param set  the set to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed {@link NavigableSet}
-     * @throws NullPointerException if set or transformer is null
+     * @throws IllegalArgumentException if set or transformer is null
      */
     public static <E> TransformedNavigableSet<E> transformingNavigableSet(final NavigableSet<E> set,
             final Transformer<? super E, ? extends E> transformer) {
@@ -67,13 +67,13 @@ public class TransformedNavigableSet<E> extends TransformedSortedSet<E> implemen
      * @param set  the set to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed {@link NavigableSet}
-     * @throws NullPointerException if set or transformer is null
+     * @throws IllegalArgumentException if set or transformer is null
      */
     public static <E> TransformedNavigableSet<E> transformedNavigableSet(final NavigableSet<E> set,
             final Transformer<? super E, ? extends E> transformer) {
 
         final TransformedNavigableSet<E> decorated = new TransformedNavigableSet<E>(set, transformer);
-        if (set.size() > 0) {
+        if (transformer != null && set != null && set.size() > 0) {
             @SuppressWarnings("unchecked") // set is type E
             final E[] values = (E[]) set.toArray(); // NOPMD - false positive for generics
             set.clear();
@@ -93,7 +93,7 @@ public class TransformedNavigableSet<E> extends TransformedSortedSet<E> implemen
      *
      * @param set  the set to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
-     * @throws NullPointerException if set or transformer is null
+     * @throws IllegalArgumentException if set or transformer is null
      */
     protected TransformedNavigableSet(final NavigableSet<E> set,
                                       final Transformer<? super E, ? extends E> transformer) {
diff --git a/src/main/java/org/apache/commons/collections4/set/TransformedSet.java b/src/main/java/org/apache/commons/collections4/set/TransformedSet.java
index f0603d05..234fcb29 100644
--- a/src/main/java/org/apache/commons/collections4/set/TransformedSet.java
+++ b/src/main/java/org/apache/commons/collections4/set/TransformedSet.java
@@ -50,7 +50,7 @@ public class TransformedSet<E> extends TransformedCollection<E> implements Set<E
      * @param set  the set to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed set
-     * @throws NullPointerException if set or transformer is null
+     * @throws IllegalArgumentException if set or transformer is null
      * @since 4.0
      */
     public static <E> TransformedSet<E> transformingSet(final Set<E> set,
@@ -70,12 +70,12 @@ public class TransformedSet<E> extends TransformedCollection<E> implements Set<E
      * @param set  the set to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed set
-     * @throws NullPointerException if set or transformer is null
+     * @throws IllegalArgumentException if set or transformer is null
      * @since 4.0
      */
     public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {
         final TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);
-        if (set.size() > 0) {
+        if (transformer != null && set != null && set.size() > 0) {
             @SuppressWarnings("unchecked") // set is type E
             final E[] values = (E[]) set.toArray(); // NOPMD - false positive for generics
             set.clear();
@@ -95,7 +95,7 @@ public class TransformedSet<E> extends TransformedCollection<E> implements Set<E
      *
      * @param set  the set to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
-     * @throws NullPointerException if set or transformer is null
+     * @throws IllegalArgumentException if set or transformer is null
      */
     protected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {
         super(set, transformer);
diff --git a/src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java b/src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java
index 29ae3fd5..9bd663b0 100644
--- a/src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java
+++ b/src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java
@@ -50,7 +50,7 @@ public class TransformedSortedSet<E> extends TransformedSet<E> implements Sorted
      * @param set  the set to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed {@link SortedSet}
-     * @throws NullPointerException if set or transformer is null
+     * @throws IllegalArgumentException if set or transformer is null
      * @since 4.0
      */
     public static <E> TransformedSortedSet<E> transformingSortedSet(final SortedSet<E> set,
@@ -70,14 +70,14 @@ public class TransformedSortedSet<E> extends TransformedSet<E> implements Sorted
      * @param set  the set to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
      * @return a new transformed {@link SortedSet}
-     * @throws NullPointerException if set or transformer is null
+     * @throws IllegalArgumentException if set or transformer is null
      * @since 4.0
      */
     public static <E> TransformedSortedSet<E> transformedSortedSet(final SortedSet<E> set,
             final Transformer<? super E, ? extends E> transformer) {
 
         final TransformedSortedSet<E> decorated = new TransformedSortedSet<E>(set, transformer);
-        if (set.size() > 0) {
+        if (transformer != null && set != null && set.size() > 0) {
             @SuppressWarnings("unchecked") // set is type E
             final E[] values = (E[]) set.toArray(); // NOPMD - false positive for generics
             set.clear();
@@ -97,7 +97,7 @@ public class TransformedSortedSet<E> extends TransformedSet<E> implements Sorted
      *
      * @param set  the set to decorate, must not be null
      * @param transformer  the transformer to use for conversion, must not be null
-     * @throws NullPointerException if set or transformer is null
+     * @throws IllegalArgumentException if set or transformer is null
      */
     protected TransformedSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {
         super(set, transformer);
diff --git a/src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java b/src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java
index ec96f335..3f0e7e74 100644
--- a/src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java
+++ b/src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java
@@ -48,7 +48,7 @@ public final class UnmodifiableNavigableSet<E>
      * @param <E> the element type
      * @param set  the set to decorate, must not be null
      * @return a new unmodifiable {@link NavigableSet}
-     * @throws NullPointerException if set is null
+     * @throws IllegalArgumentException if set is null
      */
     public static <E> NavigableSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {
         if (set instanceof Unmodifiable) {
@@ -62,7 +62,7 @@ public final class UnmodifiableNavigableSet<E>
      * Constructor that wraps (not copies).
      *
      * @param set  the set to decorate, must not be null
-     * @throws NullPointerException if set is null
+     * @throws IllegalArgumentException if set is null
      */
     private UnmodifiableNavigableSet(final NavigableSet<E> set) {
         super(set);
diff --git a/src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java b/src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java
index 40287e53..7671a8a3 100644
--- a/src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java
+++ b/src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java
@@ -46,7 +46,7 @@ public final class UnmodifiableSet<E>
      * @param <E> the element type
      * @param set  the set to decorate, must not be null
      * @return a new unmodifiable set
-     * @throws NullPointerException if set is null
+     * @throws IllegalArgumentException if set is null
      * @since 4.0
      */
     public static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {
@@ -63,7 +63,7 @@ public final class UnmodifiableSet<E>
      * Constructor that wraps (not copies).
      *
      * @param set  the set to decorate, must not be null
-     * @throws NullPointerException if set is null
+     * @throws IllegalArgumentException if set is null
      */
     @SuppressWarnings("unchecked") // safe to upcast
     private UnmodifiableSet(final Set<? extends E> set) {
diff --git a/src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java b/src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java
index 26f6d8f3..39ff5096 100644
--- a/src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java
+++ b/src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java
@@ -49,7 +49,7 @@ public final class UnmodifiableSortedSet<E>
      * @param <E> the element type
      * @param set  the set to decorate, must not be null
      * @return a new unmodifiable {@link SortedSet}
-     * @throws NullPointerException if set is null
+     * @throws IllegalArgumentException if set is null
      * @since 4.0
      */
     public static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {
@@ -64,7 +64,7 @@ public final class UnmodifiableSortedSet<E>
      * Constructor that wraps (not copies).
      *
      * @param set  the set to decorate, must not be null
-     * @throws NullPointerException if set is null
+     * @throws IllegalArgumentException if set is null
      */
     private UnmodifiableSortedSet(final SortedSet<E> set) {
         super(set);
diff --git a/src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java b/src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java
index 08026371..15a5f886 100644
--- a/src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java
@@ -38,14 +38,10 @@ public class AbstractIterableGetMapDecorator<K, V> implements IterableGet<K, V>
 
     /**
      * Create a new AbstractSplitMapDecorator.
-     * @param map the map to decorate, must not be null
-     * @throws NullPointerException if map is null
+     * @param decorated the Map to decorate
      */
-    public AbstractIterableGetMapDecorator(final Map<K, V> map) {
-        if (map == null) {
-            throw new NullPointerException("Map must not be null.");
-        }
-        this.map = map;
+    public AbstractIterableGetMapDecorator(final Map<K, V> decorated) {
+        this.map = decorated;
     }
 
     /**
diff --git a/src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java b/src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java
index cb67c457..90dfc1e8 100644
--- a/src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java
+++ b/src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java
@@ -55,7 +55,7 @@ import org.apache.commons.collections4.map.LinkedMap;
  * @since 4.0
  * @version $Id$
  *
- * @see org.apache.commons.collections4.SplitMapUtils#readableMap(org.apache.commons.collections4.Get)
+ * @see org.apache.commons.collections4.SplitMapUtils#readableMap(Get)
  * @see org.apache.commons.collections4.SplitMapUtils#writableMap(Put)
  */
 public class TransformedSplitMap<J, K, U, V> extends AbstractIterableGetMapDecorator<K, V>
@@ -80,10 +80,12 @@ public class TransformedSplitMap<J, K, U, V> extends AbstractIterableGetMapDecor
      * @param <U>  the input value type
      * @param <V>  the output value type
      * @param map the map to decorate, must not be null
-     * @param keyTransformer the transformer to use for key conversion, must not be null
-     * @param valueTransformer the transformer to use for value conversion, must not be null
+     * @param keyTransformer the transformer to use for key conversion, null
+     *   means no transformation
+     * @param valueTransformer the transformer to use for value conversion, null
+     *   means no transformation
      * @return a new transformed map
-     * @throws NullPointerException if map or either of the transformers is null
+     * @throws IllegalArgumentException if map is null
      */
     public static <J, K, U, V> TransformedSplitMap<J, K, U, V> transformingMap(final Map<K, V> map,
             final Transformer<? super J, ? extends K> keyTransformer,
@@ -99,19 +101,21 @@ public class TransformedSplitMap<J, K, U, V> extends AbstractIterableGetMapDecor
      * are NOT transformed.
      *
      * @param map the map to decorate, must not be null
-     * @param keyTransformer the transformer to use for key conversion, must not be null
-     * @param valueTransformer the transformer to use for value conversion, must not be null
-     * @throws NullPointerException if map or either of the transformers is null
+     * @param keyTransformer the transformer to use for key conversion, null
+     * means no conversion
+     * @param valueTransformer the transformer to use for value conversion, null
+     * means no conversion
+     * @throws IllegalArgumentException if map is null
      */
     protected TransformedSplitMap(final Map<K, V> map, final Transformer<? super J, ? extends K> keyTransformer,
             final Transformer<? super U, ? extends V> valueTransformer) {
         super(map);
         if (keyTransformer == null) {
-            throw new NullPointerException("KeyTransformer must not be null.");
+            throw new IllegalArgumentException("keyTransformer cannot be null");
         }
         this.keyTransformer = keyTransformer;
         if (valueTransformer == null) {
-            throw new NullPointerException("ValueTransformer must not be null.");
+            throw new IllegalArgumentException("valueTransformer cannot be null");
         }
         this.valueTransformer = valueTransformer;
     }
diff --git a/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java b/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java
index 3776fec8..feb47d63 100644
--- a/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java
+++ b/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java
@@ -49,7 +49,7 @@ public class UnmodifiableTrie<K, V> implements Trie<K, V>, Serializable, Unmodif
      * @param <V>  the value type
      * @param trie  the trie to decorate, must not be null
      * @return a new unmodifiable trie
-     * @throws NullPointerException if trie is null
+     * @throws IllegalArgumentException if trie is null
      */
     public static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {
         if (trie instanceof Unmodifiable) {
@@ -65,11 +65,11 @@ public class UnmodifiableTrie<K, V> implements Trie<K, V>, Serializable, Unmodif
      * Constructor that wraps (not copies).
      *
      * @param trie  the trie to decorate, must not be null
-     * @throws NullPointerException if trie is null
+     * @throws IllegalArgumentException if trie is null
      */
     public UnmodifiableTrie(final Trie<K, ? extends V> trie) {
         if (trie == null) {
-            throw new NullPointerException("Trie must not be null");
+            throw new IllegalArgumentException("Trie must not be null");
         }
         @SuppressWarnings("unchecked") // safe to upcast
         final Trie<K, V> tmpTrie = (Trie<K, V>) trie;
