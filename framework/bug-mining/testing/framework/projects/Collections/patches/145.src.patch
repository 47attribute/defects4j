diff --git a/src/main/java/org/apache/commons/collections4/MultiMapUtils.java b/src/main/java/org/apache/commons/collections4/MultiMapUtils.java
index 5fdee52c..bf30d900 100644
--- a/src/main/java/org/apache/commons/collections4/MultiMapUtils.java
+++ b/src/main/java/org/apache/commons/collections4/MultiMapUtils.java
@@ -23,8 +23,7 @@ import java.util.List;
 import java.util.Set;
 
 import org.apache.commons.collections4.bag.HashBag;
-import org.apache.commons.collections4.multimap.ArrayListValuedHashMap;
-import org.apache.commons.collections4.multimap.HashSetValuedHashMap;
+import org.apache.commons.collections4.multimap.MultiValuedHashMap;
 import org.apache.commons.collections4.multimap.TransformedMultiValuedMap;
 import org.apache.commons.collections4.multimap.UnmodifiableMultiValuedMap;
 
@@ -53,7 +52,7 @@ public class MultiMapUtils {
      */
     @SuppressWarnings({ "rawtypes", "unchecked" })
     public static final MultiValuedMap EMPTY_MULTI_VALUED_MAP =
-            UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(new ArrayListValuedHashMap(0, 0));
+            UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(new MultiValuedHashMap());
 
     /**
      * Returns immutable EMPTY_MULTI_VALUED_MAP with generic type safety.
@@ -189,7 +188,21 @@ public class MultiMapUtils {
      * @return a new <code>ListValuedMap</code>
      */
     public static <K, V> ListValuedMap<K, V> newListValuedHashMap() {
-        return new ArrayListValuedHashMap<K, V>();
+        return MultiValuedHashMap.<K, V>listValuedHashMap();
+    }
+
+    /**
+     * Creates a {@link ListValuedMap} with a {@link java.util.HashMap HashMap} as its internal
+     * storage which maps the keys to list of type <code>listClass</code>.
+     *
+     * @param <K> the key type
+     * @param <V> the value type
+     * @param <C> the List class type
+     * @param listClass the class of the list
+     * @return a new {@link ListValuedMap}
+     */
+    public static <K, V, C extends List<V>> ListValuedMap<K, V> newListValuedHashMap(final Class<C> listClass) {
+        return MultiValuedHashMap.<K, V, C>listValuedHashMap(listClass);
     }
 
     /**
@@ -201,7 +214,21 @@ public class MultiMapUtils {
      * @return a new {@link SetValuedMap}
      */
     public static <K, V> SetValuedMap<K, V> newSetValuedHashMap() {
-        return new HashSetValuedHashMap<K, V>();
+        return MultiValuedHashMap.<K, V>setValuedHashMap();
+    }
+
+    /**
+     * Creates a {@link SetValuedMap} with a {@link java.util.HashMap HashMap} as its internal
+     * storage which maps the keys to a set of type <code>setClass</code>
+     *
+     * @param <K> the key type
+     * @param <V> the value type
+     * @param <C> the Set class type
+     * @param setClass  the class of the set
+     * @return a new {@link SetValuedMap}
+     */
+    public static <K, V, C extends Set<V>> SetValuedMap<K, V> newSetValuedHashMap(final Class<C> setClass) {
+        return MultiValuedHashMap.<K, V, C>setValuedHashMap(setClass);
     }
 
     // MultiValuedMap Decorators
diff --git a/src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java b/src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java
index d5e3237a..dd1014eb 100644
--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java
+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java
@@ -38,28 +38,34 @@ import org.apache.commons.collections4.ListValuedMap;
 public abstract class AbstractListValuedMap<K, V> extends AbstractMultiValuedMap<K, V>
         implements ListValuedMap<K, V> {
 
-    /**
-     * Constructor needed for subclass serialisation.
-     */
-    protected AbstractListValuedMap() {
-        super();
-    }
+    /** The serialization version */
+    private static final long serialVersionUID = 20150612L;
 
     /**
      * A constructor that wraps, not copies
      *
+     * @param <C> the list type
      * @param map  the map to wrap, must not be null
+     * @param listClazz  the collection class
      * @throws NullPointerException if the map is null
      */
-    protected AbstractListValuedMap(final Map<K, ? extends List<V>> map) {
-        super(map);
+    protected <C extends List<V>> AbstractListValuedMap(final Map<K, ? super C> map, Class<C> listClazz) {
+        super(map, listClazz);
     }
 
-    // -----------------------------------------------------------------------
-    @Override
-    @SuppressWarnings("unchecked")
-    protected Map<K, List<V>> getMap() {
-        return (Map<K, List<V>>) super.getMap();
+    /**
+     * A constructor that wraps, not copies
+     *
+     * @param <C> the list type
+     * @param map  the map to wrap, must not be null
+     * @param listClazz  the collection class
+     * @param initialListCapacity  the initial size of the values list
+     * @throws NullPointerException  if the map is null
+     * @throws IllegalArgumentException  if initialListCapacity is negative
+     */
+    protected <C extends List<V>> AbstractListValuedMap(final Map<K, ? super C> map, Class<C> listClazz,
+                                                        final int initialListCapacity) {
+        super(map, listClazz, initialListCapacity);
     }
 
     /**
@@ -67,9 +73,10 @@ public abstract class AbstractListValuedMap<K, V> extends AbstractMultiValuedMap
      * @return a new list
      */
     @Override
-    protected abstract List<V> createCollection();
+    protected List<V> createCollection() {
+        return (List<V>) super.createCollection();
+    }
 
-    // -----------------------------------------------------------------------
     /**
      * Gets the list of values associated with the specified key. This would
      * return an empty list in case the mapping is not present
@@ -93,10 +100,25 @@ public abstract class AbstractListValuedMap<K, V> extends AbstractMultiValuedMap
      */
     @Override
     public List<V> remove(Object key) {
-        return ListUtils.emptyIfNull(getMap().remove(key));
+        return ListUtils.emptyIfNull((List<V>) getMap().remove(key));
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj instanceof ListValuedMap) {
+            return asMap().equals(((ListValuedMap<?, ?>) obj).asMap());
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        return asMap().hashCode();
     }
 
-    // -----------------------------------------------------------------------
     /**
      * Wrapped list to handle add and remove on the list returned by get(object)
      */
@@ -108,7 +130,7 @@ public abstract class AbstractListValuedMap<K, V> extends AbstractMultiValuedMap
 
         @Override
         protected List<V> getMapping() {
-            return getMap().get(key);
+            return (List<V>) getMap().get(key);
         }
 
         @Override
@@ -215,13 +237,13 @@ public abstract class AbstractListValuedMap<K, V> extends AbstractMultiValuedMap
 
         public ValuesListIterator(final K key) {
             this.key = key;
-            this.values = ListUtils.emptyIfNull(getMap().get(key));
+            this.values = ListUtils.emptyIfNull((List<V>) getMap().get(key));
             this.iterator = values.listIterator();
         }
 
         public ValuesListIterator(final K key, int index) {
             this.key = key;
-            this.values = ListUtils.emptyIfNull(getMap().get(key));
+            this.values = ListUtils.emptyIfNull((List<V>) getMap().get(key));
             this.iterator = values.listIterator(index);
         }
 
diff --git a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java
index f1a1e5a0..fe0a7707 100644
--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java
+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java
@@ -16,9 +16,7 @@
  */
 package org.apache.commons.collections4.multimap;
 
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
+import java.io.Serializable;
 import java.lang.reflect.Array;
 import java.util.AbstractCollection;
 import java.util.ArrayList;
@@ -29,11 +27,13 @@ import java.util.Map.Entry;
 import java.util.Set;
 
 import org.apache.commons.collections4.CollectionUtils;
+import org.apache.commons.collections4.Factory;
 import org.apache.commons.collections4.IteratorUtils;
 import org.apache.commons.collections4.MapIterator;
 import org.apache.commons.collections4.MultiSet;
 import org.apache.commons.collections4.MultiValuedMap;
 import org.apache.commons.collections4.Transformer;
+import org.apache.commons.collections4.functors.InstantiateFactory;
 import org.apache.commons.collections4.iterators.EmptyMapIterator;
 import org.apache.commons.collections4.iterators.IteratorChain;
 import org.apache.commons.collections4.iterators.LazyIteratorChain;
@@ -50,7 +50,13 @@ import org.apache.commons.collections4.set.UnmodifiableSet;
  * @since 4.1
  * @version $Id$
  */
-public abstract class AbstractMultiValuedMap<K, V> implements MultiValuedMap<K, V> {
+public abstract class AbstractMultiValuedMap<K, V> implements MultiValuedMap<K, V>, Serializable {
+
+    /** Serialization Version */
+    private static final long serialVersionUID = 20150612L;
+
+    /** The factory for creating value collections. */
+    private final Factory<? extends Collection<V>> collectionFactory;
 
     /** The values view */
     private transient Collection<V> valuesView;
@@ -62,13 +68,24 @@ public abstract class AbstractMultiValuedMap<K, V> implements MultiValuedMap<K,
     private transient KeysMultiSet keysMultiSetView;
 
     /** The map used to store the data */
-    private transient Map<K, Collection<V>> map;
+    private final Map<K, Collection<V>> map;
 
     /**
-     * Constructor needed for subclass serialisation.
+     * Constructor that wraps (not copies).
+     *
+     * @param <C> the collection type
+     * @param map  the map to wrap, must not be null
+     * @param collectionClazz  the collection class
+     * @throws NullPointerException if the map is null
      */
-    protected AbstractMultiValuedMap() {
-        super();
+    @SuppressWarnings("unchecked")
+    protected <C extends Collection<V>> AbstractMultiValuedMap(final Map<K, ? super C> map,
+                                                               final Class<C> collectionClazz) {
+        if (map == null) {
+            throw new NullPointerException("Map must not be null.");
+        }
+        this.map = (Map<K, Collection<V>>) map;
+        this.collectionFactory = new InstantiateFactory<C>(collectionClazz);
     }
 
     /**
@@ -76,41 +93,35 @@ public abstract class AbstractMultiValuedMap<K, V> implements MultiValuedMap<K,
      *
      * @param <C> the collection type
      * @param map  the map to wrap, must not be null
-     * @throws NullPointerException if the map is null
+     * @param collectionClazz  the collection class
+     * @param initialCollectionCapacity  the initial capacity of the collection
+     * @throws NullPointerException  if the map is null
+     * @throws IllegalArgumentException  if initialCollectionCapacity is negative
      */
     @SuppressWarnings("unchecked")
-    protected AbstractMultiValuedMap(final Map<K, ? extends Collection<V>> map) {
+    protected <C extends Collection<V>> AbstractMultiValuedMap(final Map<K, ? super C> map,
+            final Class<C> collectionClazz, final int initialCollectionCapacity) {
         if (map == null) {
             throw new NullPointerException("Map must not be null.");
         }
+        if (initialCollectionCapacity < 0) {
+            throw new IllegalArgumentException("InitialCapacity must not be negative.");
+        }
         this.map = (Map<K, Collection<V>>) map;
+        this.collectionFactory = new InstantiateFactory<C>(collectionClazz,
+                new Class[] { Integer.TYPE },
+                new Object[] { Integer.valueOf(initialCollectionCapacity) });
     }
 
-    // -----------------------------------------------------------------------
     /**
      * Gets the map being wrapped.
      *
      * @return the wrapped map
      */
-    protected Map<K, ? extends Collection<V>> getMap() {
+    protected Map<K, Collection<V>> getMap() {
         return map;
     }
 
-    /**
-     * Sets the map being wrapped.
-     * <p>
-     * <b>NOTE:</b> this method should only be used during deserialization
-     *
-     * @param map the map to wrap
-     */
-    @SuppressWarnings("unchecked")
-    protected void setMap(Map<K, ? extends Collection<V>> map) {
-        this.map = (Map<K, Collection<V>>) map;
-    }
-
-    protected abstract Collection<V> createCollection();
-
-    // -----------------------------------------------------------------------
     @Override
     public boolean containsKey(Object key) {
         return getMap().containsKey(key);
@@ -239,7 +250,7 @@ public abstract class AbstractMultiValuedMap<K, V> implements MultiValuedMap<K,
         if (coll == null) {
             coll = createCollection();
             if (coll.add(value)) {
-                map.put(key, coll);
+                getMap().put(key, coll);
                 return true;
             } else {
                 return false;
@@ -314,10 +325,8 @@ public abstract class AbstractMultiValuedMap<K, V> implements MultiValuedMap<K,
     }
 
     @Override
-    @SuppressWarnings("unchecked")
     public Map<K, Collection<V>> asMap() {
-        // TODO: return a view of the map
-        return (Map<K, Collection<V>>) getMap();
+        return getMap();
     }
 
     /**
@@ -364,12 +373,18 @@ public abstract class AbstractMultiValuedMap<K, V> implements MultiValuedMap<K,
 
     @Override
     public int hashCode() {
-        return asMap().hashCode();
+        return getMap().hashCode();
     }
 
     @Override
     public String toString() {
-        return asMap().toString();
+        return getMap().toString();
+    }
+
+    // -----------------------------------------------------------------------
+
+    protected Collection<V> createCollection() {
+        return collectionFactory.create();
     }
 
     // -----------------------------------------------------------------------
@@ -891,44 +906,4 @@ public abstract class AbstractMultiValuedMap<K, V> implements MultiValuedMap<K,
         }
     }
 
-    //-----------------------------------------------------------------------
-    /**
-     * Write the map out using a custom routine.
-     * @param out the output stream
-     * @throws IOException any of the usual I/O related exceptions
-     */
-    protected void doWriteObject(final ObjectOutputStream out) throws IOException {
-        out.writeInt(map.size());
-        for (final Map.Entry<K, Collection<V>> entry : map.entrySet()) {
-            out.writeObject(entry.getKey());
-            out.writeInt(entry.getValue().size());
-            for (final V value : entry.getValue()) {
-                out.writeObject(value);
-            }
-        }
-    }
-
-    /**
-     * Read the map in using a custom routine.
-     * @param in the input stream
-     * @throws IOException any of the usual I/O related exceptions
-     * @throws ClassNotFoundException if the stream contains an object which class can not be loaded
-     * @throws ClassCastException if the stream does not contain the correct objects
-     */
-    protected void doReadObject(final ObjectInputStream in)
-            throws IOException, ClassNotFoundException {
-        final int entrySize = in.readInt();
-        for (int i = 0; i < entrySize; i++) {
-            @SuppressWarnings("unchecked") // This will fail at runtime if the stream is incorrect
-            final K key = (K) in.readObject();
-            final Collection<V> values = get(key);
-            final int valueSize = in.readInt();
-            for (int j = 0; j < valueSize; j++) {
-                @SuppressWarnings("unchecked") // see above
-                V value = (V) in.readObject();
-                values.add(value);
-            }
-        }
-    }
-
 }
diff --git a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java
index ff520caa..525cfc58 100644
--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java
+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java
@@ -61,7 +61,6 @@ public abstract class AbstractMultiValuedMapDecorator<K, V>
         this.map = map;
     }
 
-    // -----------------------------------------------------------------------
     /**
      * The decorated multi-valued map.
      *
@@ -71,7 +70,6 @@ public abstract class AbstractMultiValuedMapDecorator<K, V>
         return map;
     }
 
-    // -----------------------------------------------------------------------
     @Override
     public int size() {
         return decorated().size();
diff --git a/src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java b/src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java
index bcfa20af..5355f6d6 100644
--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java
+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java
@@ -36,38 +36,36 @@ import org.apache.commons.collections4.SetValuedMap;
 public abstract class AbstractSetValuedMap<K, V> extends AbstractMultiValuedMap<K, V>
     implements SetValuedMap<K, V> {
 
-    /**
-     * Constructor needed for subclass serialisation.
-     */
-    protected AbstractSetValuedMap() {
-        super();
-    }
+    /** Serialization version */
+    private static final long serialVersionUID = 20150612L;
 
     /**
      * A constructor that wraps, not copies
      *
+     * @param <C> the set type
      * @param map  the map to wrap, must not be null
+     * @param setClazz  the collection class
      * @throws NullPointerException if the map is null
      */
-    protected AbstractSetValuedMap(Map<K, ? extends Set<V>> map) {
-        super(map);
-    }
-
-    // -----------------------------------------------------------------------
-    @Override
-    @SuppressWarnings("unchecked")
-    protected Map<K, Set<V>> getMap() {
-        return (Map<K, Set<V>>) super.getMap();
+    protected <C extends Set<V>> AbstractSetValuedMap(Map<K, ? super C> map, Class<C> setClazz) {
+        super(map, setClazz);
     }
 
     /**
-     * Creates a new value collection using the provided factory.
-     * @return a new list
+     * A constructor that wraps, not copies
+     *
+     * @param <C> the set type
+     * @param map  the map to wrap, must not be null
+     * @param setClazz  the collection class
+     * @param initialSetCapacity  the initial size of the values set
+     * @throws NullPointerException if the map is null
+     * @throws IllegalArgumentException if initialSetCapacity is negative
      */
-    @Override
-    protected abstract Set<V> createCollection();
+    protected <C extends Set<V>> AbstractSetValuedMap(Map<K, ? super C> map, Class<C> setClazz,
+            int initialSetCapacity) {
+        super(map, setClazz, initialSetCapacity);
+    }
 
-    // -----------------------------------------------------------------------
     /**
      * Gets the set of values associated with the specified key. This would
      * return an empty set in case the mapping is not present
@@ -92,10 +90,25 @@ public abstract class AbstractSetValuedMap<K, V> extends AbstractMultiValuedMap<
      */
     @Override
     public Set<V> remove(Object key) {
-        return SetUtils.emptyIfNull(getMap().remove(key));
+        return SetUtils.emptyIfNull((Set<V>) getMap().remove(key));
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj instanceof SetValuedMap) {
+            return asMap().equals(((SetValuedMap<?, ?>) obj).asMap());
+        }
+        return false;
+    }
+
+    @Override
+    public int hashCode() {
+        return asMap().hashCode();
     }
 
-    // -----------------------------------------------------------------------
     /**
      * Wrapped set to handle add and remove on the collection returned by
      * {@code get(Object)}.
diff --git a/src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java b/src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java
deleted file mode 100644
index 2d4fa648..00000000
--- a/src/main/java/org/apache/commons/collections4/multimap/ArrayListValuedHashMap.java
+++ /dev/null
@@ -1,128 +0,0 @@
-package org.apache.commons.collections4.multimap;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.commons.collections4.ListValuedMap;
-import org.apache.commons.collections4.MultiValuedMap;
-
-/**
- * Implements a {@link ListValuedMap}, using a {@link HashMap} to provide data
- * storage and {@link ArrayList}s as value collections. This is the standard
- * implementation of a ListValuedMap.
- * <p>
- * <strong>Note that ArrayListValuedHashMap is not synchronized and is not
- * thread-safe.</strong> If you wish to use this map from multiple threads
- * concurrently, you must use appropriate synchronization. This class may throw
- * exceptions when accessed by concurrent threads without synchronization.
- *
- * @since 4.1
- * @version $Id$
- */
-public class ArrayListValuedHashMap<K, V> extends AbstractListValuedMap<K, V>
-    implements Serializable {
-
-    /** Serialization Version */
-    private static final long serialVersionUID = 20151118L;
-
-    /**
-     * The initial map capacity used when none specified in constructor.
-     */
-    private static final int DEFAULT_INITIAL_MAP_CAPACITY = 16;
-
-    /**
-     * The initial list capacity when using none specified in constructor.
-     */
-    private static final int DEFAULT_INITIAL_LIST_CAPACITY = 3;
-
-    /**
-     * The initial list capacity when creating a new value collection.
-     */
-    private final int initialListCapacity;
-
-    /**
-     * Creates an empty ArrayListValuedHashMap with the default initial
-     * map capacity (16) and the default initial list capacity (3). 
-     */
-    public ArrayListValuedHashMap() {
-        this(DEFAULT_INITIAL_MAP_CAPACITY, DEFAULT_INITIAL_LIST_CAPACITY);
-    }
-
-    /**
-     * Creates an empty ArrayListValuedHashMap with the default initial
-     * map capacity (16) and the specified initial list capacity. 
-     *
-     * @param initialListCapacity  the initial capacity used for value collections
-     */
-    public ArrayListValuedHashMap(int initialListCapacity) {
-        this(DEFAULT_INITIAL_MAP_CAPACITY, initialListCapacity);
-    }
-
-    /**
-     * Creates an empty ArrayListValuedHashMap with the specified initial
-     * map and list capacities. 
-     *
-     * @param initialMapCapacity  the initial hashmap capacity
-     * @param initialListCapacity  the initial capacity used for value collections
-     */
-    public ArrayListValuedHashMap(int initialMapCapacity, int initialListCapacity) {
-        super(new HashMap<K, ArrayList<V>>(initialMapCapacity));
-        this.initialListCapacity = initialListCapacity;
-    }
-
-    /**
-     * Creates an ArrayListValuedHashMap copying all the mappings of the given map.
-     *
-     * @param map a <code>MultiValuedMap</code> to copy into this map
-     */
-    public ArrayListValuedHashMap(final MultiValuedMap<? extends K, ? extends V> map) {
-        this(map.size(), DEFAULT_INITIAL_LIST_CAPACITY);
-        super.putAll(map);
-    }
-
-    /**
-     * Creates an ArrayListValuedHashMap copying all the mappings of the given map.
-     *
-     * @param map a <code>Map</code> to copy into this map
-     */
-    public ArrayListValuedHashMap(final Map<? extends K, ? extends V> map) {
-        this(map.size(), DEFAULT_INITIAL_LIST_CAPACITY);
-        super.putAll(map);
-    }
-
-    // -----------------------------------------------------------------------
-    @Override
-    protected ArrayList<V> createCollection() {
-        return new ArrayList<V>(initialListCapacity);
-    }
-
-    // -----------------------------------------------------------------------
-    /**
-     * Trims the capacity of all value collections to their current size.
-     */
-    public void trimToSize() {
-        for (Collection<V> coll : getMap().values()) {
-            final ArrayList<V> list = (ArrayList<V>) coll;
-            list.trimToSize();
-        }
-    }
-
-    // -----------------------------------------------------------------------
-    private void writeObject(ObjectOutputStream oos) throws IOException {
-        oos.defaultWriteObject();
-        doWriteObject(oos);
-    }
-    
-    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
-        ois.defaultReadObject();
-        setMap(new HashMap<K, ArrayList<V>>());
-        doReadObject(ois);
-    }
-
-}
diff --git a/src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java b/src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java
deleted file mode 100644
index 5737368c..00000000
--- a/src/main/java/org/apache/commons/collections4/multimap/HashSetValuedHashMap.java
+++ /dev/null
@@ -1,116 +0,0 @@
-package org.apache.commons.collections4.multimap;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-
-import org.apache.commons.collections4.MultiValuedMap;
-import org.apache.commons.collections4.SetValuedMap;
-
-/**
- * Implements a {@link SetValuedMap}, using a {@link HashMap} to provide data
- * storage and {@link HashSet}s as value collections. This is the standard
- * implementation of a SetValuedMap.
- * <p>
- * <strong>Note that HashSetValuedHashMap is not synchronized and is not
- * thread-safe.</strong> If you wish to use this map from multiple threads
- * concurrently, you must use appropriate synchronization. This class may throw
- * exceptions when accessed by concurrent threads without synchronization.
- *
- * @since 4.1
- * @version $Id$
- */
-public class HashSetValuedHashMap<K, V> extends AbstractSetValuedMap<K, V>
-    implements Serializable {
-
-    /** Serialization Version */
-    private static final long serialVersionUID = 20151118L;
-
-    /**
-     * The initial map capacity used when none specified in constructor.
-     */
-    private static final int DEFAULT_INITIAL_MAP_CAPACITY = 16;
-
-    /**
-     * The initial set capacity when using none specified in constructor.
-     */
-    private static final int DEFAULT_INITIAL_SET_CAPACITY = 3;
-
-    /**
-     * The initial list capacity when creating a new value collection.
-     */
-    private final int initialSetCapacity;
-
-    /**
-     * Creates an empty HashSetValuedHashMap with the default initial
-     * map capacity (16) and the default initial set capacity (3). 
-     */
-    public HashSetValuedHashMap() {
-        this(DEFAULT_INITIAL_MAP_CAPACITY, DEFAULT_INITIAL_SET_CAPACITY);
-    }
-
-    /**
-     * Creates an empty HashSetValuedHashMap with the default initial
-     * map capacity (16) and the specified initial set capacity. 
-     *
-     * @param initialSetCapacity  the initial capacity used for value collections
-     */
-    public HashSetValuedHashMap(int initialSetCapacity) {
-        this(DEFAULT_INITIAL_MAP_CAPACITY, initialSetCapacity);
-    }
-
-    /**
-     * Creates an empty HashSetValuedHashMap with the specified initial
-     * map and list capacities. 
-     *
-     * @param initialMapCapacity  the initial hashmap capacity
-     * @param initialSetCapacity  the initial capacity used for value collections
-     */
-    public HashSetValuedHashMap(int initialMapCapacity, int initialSetCapacity) {
-        super(new HashMap<K, HashSet<V>>(initialMapCapacity));
-        this.initialSetCapacity = initialSetCapacity;
-    }
-
-    /**
-     * Creates an HashSetValuedHashMap copying all the mappings of the given map.
-     *
-     * @param map a <code>MultiValuedMap</code> to copy into this map
-     */
-    public HashSetValuedHashMap(final MultiValuedMap<? extends K, ? extends V> map) {
-        this(map.size(), DEFAULT_INITIAL_SET_CAPACITY);
-        super.putAll(map);
-    }
-
-    /**
-     * Creates an HashSetValuedHashMap copying all the mappings of the given map.
-     *
-     * @param map a <code>Map</code> to copy into this map
-     */
-    public HashSetValuedHashMap(final Map<? extends K, ? extends V> map) {
-        this(map.size(), DEFAULT_INITIAL_SET_CAPACITY);
-        super.putAll(map);
-    }
-
-    // -----------------------------------------------------------------------
-    @Override
-    protected HashSet<V> createCollection() {
-        return new HashSet<V>(initialSetCapacity);
-    }
-
-    // -----------------------------------------------------------------------
-    private void writeObject(ObjectOutputStream oos) throws IOException {
-        oos.defaultWriteObject();
-        doWriteObject(oos);
-    }
-    
-    private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
-        ois.defaultReadObject();
-        setMap(new HashMap<K, HashSet<V>>());
-        doReadObject(ois);
-    }
-
-}
diff --git a/src/main/java/org/apache/commons/collections4/multimap/MultiValuedHashMap.java b/src/main/java/org/apache/commons/collections4/multimap/MultiValuedHashMap.java
new file mode 100644
index 00000000..d0a5704a
--- /dev/null
+++ b/src/main/java/org/apache/commons/collections4/multimap/MultiValuedHashMap.java
@@ -0,0 +1,259 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.commons.collections4.multimap;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.commons.collections4.ListValuedMap;
+import org.apache.commons.collections4.MultiValuedMap;
+import org.apache.commons.collections4.SetValuedMap;
+
+/**
+ * Implements a {@link MultiValuedMap}, using a {@link HashMap} to provide data
+ * storage. This is the standard implementation of a MultiValuedMap
+ * <p>
+ * A <code>MultiValuedMap</code> is a Map with slightly different semantics.
+ * Putting a value into the map will add the value to a Collection at that key.
+ * Getting a value will return a Collection, holding all the values put to that
+ * key
+ * <p>
+ * In addition, this implementation allows the type of collection used for the
+ * values to be controlled. By default, an <code>ArrayList</code> is used,
+ * however a <code>Class<? extends Collection></code> to instantiate the value
+ * collection may be specified.
+ * <p>
+ * <strong>Note that MultiValuedHashMap is not synchronized and is not
+ * thread-safe.</strong> If you wish to use this map from multiple threads
+ * concurrently, you must use appropriate synchronization. This class may throw
+ * exceptions when accessed by concurrent threads without synchronization.
+ *
+ * @since 4.1
+ * @version $Id$
+ */
+public class MultiValuedHashMap<K, V> extends AbstractMultiValuedMap<K, V> {
+
+    /** Serialization Version */
+    private static final long serialVersionUID = 20150612L;
+
+    /**
+     * The initial capacity used when none specified in constructor.
+     */
+    static final int DEFAULT_INITIAL_CAPACITY = 16;
+
+    /**
+     * The load factor used when none specified in constructor.
+     */
+    static final float DEFAULT_LOAD_FACTOR = 0.75f;
+
+    /**
+     * Creates a {@link ListValuedMap} with a {@link HashMap} as its internal
+     * storage
+     *
+     * @param <K> the key type
+     * @param <V> the value type
+     * @return a new <code>ListValuedMap</code>
+     */
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    public static <K, V> ListValuedMap<K, V> listValuedHashMap() {
+        return new ListValuedHashMap(ArrayList.class);
+    }
+
+    /**
+     * Creates a {@link ListValuedMap} with a {@link HashMap} as its internal
+     * storage which maps the keys to list of type <code>listClass</code>
+     *
+     * @param <K> the key type
+     * @param <V> the value type
+     * @param <C> the List class type
+     * @param listClass the class of the list
+     * @return a new <code>ListValuedMap</code>
+     */
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    public static <K, V, C extends List<V>> ListValuedMap<K, V> listValuedHashMap(final Class<C> listClass) {
+        return new ListValuedHashMap(listClass);
+    }
+
+    /**
+     * Creates a {@link SetValuedMap} with a {@link HashMap} as its internal
+     * storage
+     *
+     * @param <K> the key type
+     * @param <V> the value type
+     * @return a new <code>SetValuedMap</code>
+     */
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    public static <K, V> SetValuedMap<K, V> setValuedHashMap() {
+        return new SetValuedHashMap(HashSet.class);
+    }
+
+    /**
+     * Creates a {@link SetValuedMap} with a {@link HashMap} as its internal
+     * storage which maps the keys to a set of type <code>setClass</code>
+     *
+     * @param <K> the key type
+     * @param <V> the value type
+     * @param <C> the Set class type
+     * @param setClass the class of the set
+     * @return a new <code>SetValuedMap</code>
+     */
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    public static <K, V, C extends Set<V>> SetValuedMap<K, V> setValuedHashMap(final Class<C> setClass) {
+        return new SetValuedHashMap(setClass);
+    }
+
+    /**
+     * Creates a MultiValueMap based on a <code>HashMap</code> with the default
+     * initial capacity (16) and the default load factor (0.75), which stores
+     * the multiple values in an <code>ArrayList</code>.
+     */
+    @SuppressWarnings("unchecked")
+    public MultiValuedHashMap() {
+        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, ArrayList.class);
+    }
+
+    /**
+     * Creates a MultiValueMap based on a <code>HashMap</code> with the initial
+     * capacity and the default load factor (0.75), which stores the multiple
+     * values in an <code>ArrayList</code>.
+     *
+     * @param initialCapacity the initial capacity of the underlying hash map
+     */
+    @SuppressWarnings("unchecked")
+    public MultiValuedHashMap(int initialCapacity) {
+        this(initialCapacity, DEFAULT_LOAD_FACTOR, ArrayList.class);
+    }
+
+    /**
+     * Creates a MultiValueMap based on a <code>HashMap</code> with the initial
+     * capacity and the load factor, which stores the multiple values in an
+     * <code>ArrayList</code>.
+     *
+     * @param initialCapacity the initial capacity of the underlying hash map
+     * @param loadFactor the load factor of the underlying hash map
+     */
+    @SuppressWarnings("unchecked")
+    public MultiValuedHashMap(int initialCapacity, float loadFactor) {
+        this(initialCapacity, loadFactor, ArrayList.class);
+    }
+
+    /**
+     * Creates a MultiValueMap based on a <code>HashMap</code> with the initial
+     * capacity and the load factor, which stores the multiple values in an
+     * <code>ArrayList</code> with the initial collection capacity.
+     *
+     * @param initialCapacity the initial capacity of the underlying hash map
+     * @param loadFactor the load factor of the underlying hash map
+     * @param initialCollectionCapacity the initial capacity of the Collection of values
+     */
+    @SuppressWarnings("unchecked")
+    public MultiValuedHashMap(int initialCapacity, float loadFactor, int initialCollectionCapacity) {
+        this(initialCapacity, loadFactor, ArrayList.class, initialCollectionCapacity);
+    }
+
+    /**
+     * Creates a MultiValuedHashMap copying all the mappings of the given map.
+     *
+     * @param map a <code>MultiValuedMap</code> to copy into this map
+     */
+    @SuppressWarnings("unchecked")
+    public MultiValuedHashMap(final MultiValuedMap<? extends K, ? extends V> map) {
+        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, ArrayList.class);
+        super.putAll(map);
+    }
+
+    /**
+     * Creates a MultiValuedHashMap copying all the mappings of the given map.
+     *
+     * @param map a <code>Map</code> to copy into this map
+     */
+    @SuppressWarnings("unchecked")
+    public MultiValuedHashMap(final Map<? extends K, ? extends V> map) {
+        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, ArrayList.class);
+        super.putAll(map);
+    }
+
+    /**
+     * Creates a MultiValuedHashMap which creates the value collections using
+     * the supplied <code>collectionClazz</code>.
+     *
+     * @param initialCapacity the initial capacity of the underlying
+     *        <code>HashMap</code>
+     * @param loadFactor the load factor of the underlying <code>HashMap</code>
+     * @param <C> the collection type
+     * @param collectionClazz the class of the <code>Collection</code> to use to
+     *        create the value collections
+     */
+    protected <C extends Collection<V>> MultiValuedHashMap(int initialCapacity, float loadFactor,
+            final Class<C> collectionClazz) {
+        super(new HashMap<K, Collection<V>>(initialCapacity, loadFactor), collectionClazz);
+    }
+
+    /**
+     * Creates a MultiValuedHashMap which creates the value collections using
+     * the supplied <code>collectionClazz</code> and the initial collection capacity.
+     *
+     * @param <C> the collection type
+     * @param initialCapacity the initial capacity of the underlying <code>HashMap</code>
+     * @param loadFactor the load factor of the underlying <code>HashMap</code>
+     * @param initialCollectionCapacity the initial capacity of the <code>Collection</code>
+     * @param collectionClazz the class of the <code>Collection</code> to use to create the value collections
+     */
+    protected <C extends Collection<V>> MultiValuedHashMap(int initialCapacity, float loadFactor,
+            final Class<C> collectionClazz, int initialCollectionCapacity) {
+        super(new HashMap<K, Collection<V>>(initialCapacity, loadFactor), collectionClazz,
+                                            initialCollectionCapacity);
+    }
+
+    /** Inner class for ListValuedMap */
+    private static class ListValuedHashMap<K, V> extends AbstractListValuedMap<K, V> {
+
+        private static final long serialVersionUID = 20150612L;
+
+        public <C extends List<V>> ListValuedHashMap(Class<C> listClazz) {
+            super(new HashMap<K, List<V>>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR), listClazz);
+        }
+
+        public <C extends List<V>> ListValuedHashMap(Class<C> listClazz, int initialListCapacity) {
+            super(new HashMap<K, List<V>>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR), listClazz,
+                    initialListCapacity);
+        }
+
+    }
+
+    /** Inner class for SetValuedMap */
+    private static class SetValuedHashMap<K, V> extends AbstractSetValuedMap<K, V> {
+
+        private static final long serialVersionUID = 20150612L;
+
+        public <C extends Set<V>> SetValuedHashMap(Class<C> setClazz) {
+            super(new HashMap<K, Set<V>>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR), setClazz);
+        }
+
+        public <C extends Set<V>> SetValuedHashMap(Class<C> setClazz, int initialSetCapacity) {
+            super(new HashMap<K, Set<V>>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR), setClazz,
+                    initialSetCapacity);
+        }
+
+    }
+
+}
diff --git a/src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java b/src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java
index 93a4a8b3..f0edd332 100644
--- a/src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java
+++ b/src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java
@@ -91,7 +91,7 @@ public class TransformedMultiValuedMap<K, V> extends AbstractMultiValuedMapDecor
         final TransformedMultiValuedMap<K, V> decorated =
                 new TransformedMultiValuedMap<K, V>(map, keyTransformer, valueTransformer);
         if (!map.isEmpty()) {
-            final MultiValuedMap<K, V> mapCopy = new ArrayListValuedHashMap<K, V>(map);
+            final MultiValuedMap<K, V> mapCopy = new MultiValuedHashMap<K, V>(map);
             decorated.clear();
             decorated.putAll(mapCopy);
         }
diff --git a/src/main/java/org/apache/commons/collections4/multimap/package-info.java b/src/main/java/org/apache/commons/collections4/multimap/package-info.java
index 030d3fe1..ace5aa15 100644
--- a/src/main/java/org/apache/commons/collections4/multimap/package-info.java
+++ b/src/main/java/org/apache/commons/collections4/multimap/package-info.java
@@ -20,8 +20,9 @@
  * <p>
  * The following implementations are provided in the package:
  * <ul>
- *   <li>ArrayListValuedHashMap - ListValuedMap implementation using a HashMap/ArrayList
- *   <li>HashSetValuedHashMap   - SetValuedMap implementation using a HashMap/HashSet
+ *   <li>MultiValuedHashMap - implementation that uses a HashMap to store the data
+ *   <li>ListValuedHashMap  - implementation of a ListValuedMap using a HashMap as data store
+ *   <li>SetValuedHashMap   - implementation of a SetValuedMap using a HashMap as data store
  * </ul>
  * <p>
  * The following decorators are provided in the package:
