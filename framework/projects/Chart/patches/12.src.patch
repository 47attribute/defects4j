Index: org/jfree/chart/plot/MultiplePiePlot.java
===================================================================
--- org/jfree/chart/plot/MultiplePiePlot.java	(revision 852)
+++ org/jfree/chart/plot/MultiplePiePlot.java	(revision 846)
@@ -2,35 +2,35 @@
  * JFreeChart : a free chart library for the Java(tm) platform
  * ===========================================================
  *
- * (C) Copyright 2000-2008, by Object Refinery Limited and Contributors.
+ * (C) Copyright 2000-2007, by Object Refinery Limited and Contributors.
  *
  * Project Info:  http://www.jfree.org/jfreechart/index.html
  *
- * This library is free software; you can redistribute it and/or modify it
- * under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2.1 of the License, or
+ * This library is free software; you can redistribute it and/or modify it 
+ * under the terms of the GNU Lesser General Public License as published by 
+ * the Free Software Foundation; either version 2.1 of the License, or 
  * (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
+ * This library is distributed in the hope that it will be useful, but 
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+ * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 
  * License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
- * USA.
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, 
+ * USA.  
  *
- * [Java is a trademark or registered trademark of Sun Microsystems, Inc.
+ * [Java is a trademark or registered trademark of Sun Microsystems, Inc. 
  * in the United States and other countries.]
  *
  * --------------------
  * MultiplePiePlot.java
  * --------------------
- * (C) Copyright 2004-2008, by Object Refinery Limited.
+ * (C) Copyright 2004-2007, by Object Refinery Limited.
  *
  * Original Author:  David Gilbert (for Object Refinery Limited);
- * Contributor(s):   Brian Cabana (patch 1943021);
+ * Contributor(s):   -;
  *
  * Changes
  * -------
@@ -48,8 +48,6 @@
  * 17-May-2007 : Added argument check to setPieChart() (DG);
  * 18-May-2007 : Set dataset for LegendItem (DG);
  * 20-Jun-2007 : Removed JCommon dependencies (DG);
- * 18-Apr-2008 : In the constructor, register the plot as a dataset listener -
- *               see patch 1943021 from Brian Cabana (DG);
  *
  */
 
@@ -90,65 +88,65 @@
 import org.jfree.data.general.PieDataset;
 
 /**
- * A plot that displays multiple pie plots using data from a
+ * A plot that displays multiple pie plots using data from a 
  * {@link CategoryDataset}.
  */
 public class MultiplePiePlot extends Plot implements Cloneable, Serializable {
-
+    
     /** For serialization. */
     private static final long serialVersionUID = -355377800470807389L;
-
+    
     /** The chart object that draws the individual pie charts. */
     private JFreeChart pieChart;
-
+    
     /** The dataset. */
     private CategoryDataset dataset;
-
+    
     /** The data extract order (by row or by column). */
     private TableOrder dataExtractOrder;
-
+    
     /** The pie section limit percentage. */
     private double limit = 0.0;
-
-    /**
-     * The key for the aggregated items.
+    
+    /** 
+     * The key for the aggregated items. 
      * @since 1.0.2
      */
     private Comparable aggregatedItemsKey;
-
-    /**
-     * The paint for the aggregated items.
+    
+    /** 
+     * The paint for the aggregated items. 
      * @since 1.0.2
      */
     private transient Paint aggregatedItemsPaint;
-
-    /**
-     * The colors to use for each section.
+    
+    /** 
+     * The colors to use for each section. 
      * @since 1.0.2
      */
     private transient Map sectionPaints;
-
+    
     /**
      * Creates a new plot with no data.
      */
     public MultiplePiePlot() {
         this(null);
     }
-
+    
     /**
      * Creates a new plot.
-     *
+     * 
      * @param dataset  the dataset (<code>null</code> permitted).
      */
     public MultiplePiePlot(CategoryDataset dataset) {
         super();
-        setDataset(dataset);
+        this.dataset = dataset;
         PiePlot piePlot = new PiePlot(null);
         this.pieChart = new JFreeChart(piePlot);
         this.pieChart.removeLegend();
         this.dataExtractOrder = TableOrder.BY_COLUMN;
         this.pieChart.setBackgroundPaint(null);
-        TextTitle seriesTitle = new TextTitle("Series Title",
+        TextTitle seriesTitle = new TextTitle("Series Title", 
                 new Font("SansSerif", Font.BOLD, 12));
         seriesTitle.setPosition(RectangleEdge.BOTTOM);
         this.pieChart.setTitle(seriesTitle);
@@ -156,24 +154,24 @@
         this.aggregatedItemsPaint = Color.lightGray;
         this.sectionPaints = new HashMap();
     }
-
+    
     /**
      * Returns the dataset used by the plot.
-     *
+     * 
      * @return The dataset (possibly <code>null</code>).
      */
     public CategoryDataset getDataset() {
-        return this.dataset;
+        return this.dataset;   
     }
-
+    
     /**
      * Sets the dataset used by the plot and sends a {@link PlotChangeEvent}
      * to all registered listeners.
-     *
+     * 
      * @param dataset  the dataset (<code>null</code> permitted).
      */
     public void setDataset(CategoryDataset dataset) {
-        // if there is an existing dataset, remove the plot from the list of
+        // if there is an existing dataset, remove the plot from the list of 
         // change listeners...
         if (this.dataset != null) {
             this.dataset.removeChangeListener(this);
@@ -189,22 +187,22 @@
         // send a dataset change event to self to trigger plot change event
         datasetChanged(new DatasetChangeEvent(this, dataset));
     }
-
+    
     /**
      * Returns the pie chart that is used to draw the individual pie plots.
-     *
+     * 
      * @return The pie chart (never <code>null</code>).
-     *
+     * 
      * @see #setPieChart(JFreeChart)
      */
     public JFreeChart getPieChart() {
         return this.pieChart;
     }
-
+    
     /**
      * Sets the chart that is used to draw the individual pie plots.  The
      * chart's plot must be an instance of {@link PiePlot}.
-     *
+     * 
      * @param pieChart  the pie chart (<code>null</code> not permitted).
      *
      * @see #getPieChart()
@@ -220,20 +218,20 @@
         this.pieChart = pieChart;
         fireChangeEvent();
     }
-
+    
     /**
      * Returns the data extract order (by row or by column).
-     *
+     * 
      * @return The data extract order (never <code>null</code>).
      */
     public TableOrder getDataExtractOrder() {
         return this.dataExtractOrder;
     }
-
+    
     /**
-     * Sets the data extract order (by row or by column) and sends a
+     * Sets the data extract order (by row or by column) and sends a 
      * {@link PlotChangeEvent} to all registered listeners.
-     *
+     * 
      * @param order  the order (<code>null</code> not permitted).
      */
     public void setDataExtractOrder(TableOrder order) {
@@ -243,46 +241,46 @@
         this.dataExtractOrder = order;
         fireChangeEvent();
     }
-
+    
     /**
-     * Returns the limit (as a percentage) below which small pie sections are
+     * Returns the limit (as a percentage) below which small pie sections are 
      * aggregated.
-     *
+     * 
      * @return The limit percentage.
      */
     public double getLimit() {
         return this.limit;
     }
-
+    
     /**
-     * Sets the limit below which pie sections are aggregated.
+     * Sets the limit below which pie sections are aggregated.  
      * Set this to 0.0 if you don't want any aggregation to occur.
-     *
+     * 
      * @param limit  the limit percent.
      */
     public void setLimit(double limit) {
         this.limit = limit;
         fireChangeEvent();
     }
-
+    
     /**
      * Returns the key for aggregated items in the pie plots, if there are any.
      * The default value is "Other".
-     *
+     * 
      * @return The aggregated items key.
-     *
+     * 
      * @since 1.0.2
      */
     public Comparable getAggregatedItemsKey() {
         return this.aggregatedItemsKey;
     }
-
+    
     /**
-     * Sets the key for aggregated items in the pie plots.  You must ensure
+     * Sets the key for aggregated items in the pie plots.  You must ensure 
      * that this doesn't clash with any keys in the dataset.
-     *
+     * 
      * @param key  the key (<code>null</code> not permitted).
-     *
+     * 
      * @since 1.0.2
      */
     public void setAggregatedItemsKey(Comparable key) {
@@ -292,25 +290,25 @@
         this.aggregatedItemsKey = key;
         fireChangeEvent();
     }
-
+    
     /**
-     * Returns the paint used to draw the pie section representing the
+     * Returns the paint used to draw the pie section representing the 
      * aggregated items.  The default value is <code>Color.lightGray</code>.
-     *
+     * 
      * @return The paint.
-     *
+     * 
      * @since 1.0.2
      */
     public Paint getAggregatedItemsPaint() {
         return this.aggregatedItemsPaint;
     }
-
+    
     /**
      * Sets the paint used to draw the pie section representing the aggregated
      * items and sends a {@link PlotChangeEvent} to all registered listeners.
-     *
+     * 
      * @param paint  the paint (<code>null</code> not permitted).
-     *
+     * 
      * @since 1.0.2
      */
     public void setAggregatedItemsPaint(Paint paint) {
@@ -320,19 +318,19 @@
         this.aggregatedItemsPaint = paint;
         fireChangeEvent();
     }
-
+    
     /**
      * Returns a short string describing the type of plot.
      *
      * @return The plot type.
      */
     public String getPlotType() {
-        return "Multiple Pie Plot";
+        return "Multiple Pie Plot";  
          // TODO: need to fetch this from localised resources
     }
 
     /**
-     * Draws the plot on a Java 2D graphics device (such as the screen or a
+     * Draws the plot on a Java 2D graphics device (such as the screen or a 
      * printer).
      *
      * @param g2  the graphics device.
@@ -341,19 +339,19 @@
      * @param parentState  the state from the parent plot, if there is one.
      * @param info  collects info about the drawing.
      */
-    public void draw(Graphics2D g2,
+    public void draw(Graphics2D g2, 
                      Rectangle2D area,
                      Point2D anchor,
                      PlotState parentState,
                      PlotRenderingInfo info) {
-
-
+        
+       
         // adjust the drawing area for the plot insets (if any)...
         RectangleInsets insets = getInsets();
         insets.trim(area);
         drawBackground(g2, area);
         drawOutline(g2, area);
-
+        
         // check that there is some data to display...
         if (DatasetUtilities.isEmptyOrNull(this.dataset)) {
             drawNoDataMessage(g2, area);
@@ -370,7 +368,7 @@
 
         // the columns variable is always >= rows
         int displayCols = (int) Math.ceil(Math.sqrt(pieCount));
-        int displayRows
+        int displayRows 
             = (int) Math.ceil((double) pieCount / (double) displayCols);
 
         // swap rows and columns to match plotArea shape
@@ -381,7 +379,7 @@
         }
 
         prefetchSectionPaints();
-
+        
         int x = (int) area.getX();
         int y = (int) area.getY();
         int width = ((int) area.getWidth()) / displayCols;
@@ -393,7 +391,7 @@
         Rectangle rect = new Rectangle();
 
         for (int pieIndex = 0; pieIndex < pieCount; pieIndex++) {
-            rect.setBounds(x + xoffset + (width * column), y + (height * row),
+            rect.setBounds(x + xoffset + (width * column), y + (height * row), 
                     width, height);
 
             String title = null;
@@ -404,9 +402,9 @@
                 title = this.dataset.getColumnKey(pieIndex).toString();
             }
             this.pieChart.setTitle(title);
-
+            
             PieDataset piedataset = null;
-            PieDataset dd = new CategoryToPieDataset(this.dataset,
+            PieDataset dd = new CategoryToPieDataset(this.dataset, 
                     this.dataExtractOrder, pieIndex);
             if (this.limit > 0.0) {
                 piedataset = DatasetUtilities.createConsolidatedPieDataset(
@@ -418,7 +416,7 @@
             PiePlot piePlot = (PiePlot) this.pieChart.getPlot();
             piePlot.setDataset(piedataset);
             piePlot.setPieIndex(pieIndex);
-
+            
             // update the section colors to match the global colors...
             for (int i = 0; i < piedataset.getItemCount(); i++) {
                 Comparable key = piedataset.getKey(i);
@@ -431,7 +429,7 @@
                 }
                 piePlot.setSectionPaint(key, p);
             }
-
+            
             ChartRenderingInfo subinfo = null;
             if (info != null) {
                 subinfo = new ChartRenderingInfo();
@@ -442,7 +440,7 @@
                         subinfo.getEntityCollection());
                 info.addSubplotInfo(subinfo.getPlotInfo());
             }
-
+            
             ++column;
             if (column == displayCols) {
                 column = 0;
@@ -455,26 +453,26 @@
         }
 
     }
-
+    
     /**
      * For each key in the dataset, check the <code>sectionPaints</code>
-     * cache to see if a paint is associated with that key and, if not,
+     * cache to see if a paint is associated with that key and, if not, 
      * fetch one from the drawing supplier.  These colors are cached so that
      * the legend and all the subplots use consistent colors.
      */
     private void prefetchSectionPaints() {
-
+        
         // pre-fetch the colors for each key...this is because the subplots
         // may not display every key, but we need the coloring to be
         // consistent...
-
+        
         PiePlot piePlot = (PiePlot) getPieChart().getPlot();
-
+        
         if (this.dataExtractOrder == TableOrder.BY_ROW) {
             // column keys provide potential keys for individual pies
             for (int c = 0; c < this.dataset.getColumnCount(); c++) {
                 Comparable key = this.dataset.getColumnKey(c);
-                Paint p = piePlot.getSectionPaint(key);
+                Paint p = piePlot.getSectionPaint(key); 
                 if (p == null) {
                     p = (Paint) this.sectionPaints.get(key);
                     if (p == null) {
@@ -485,10 +483,10 @@
             }
         }
         else {
-            // row keys provide potential keys for individual pies
+            // row keys provide potential keys for individual pies            
             for (int r = 0; r < this.dataset.getRowCount(); r++) {
                 Comparable key = this.dataset.getRowKey(r);
-                Paint p = piePlot.getSectionPaint(key);
+                Paint p = piePlot.getSectionPaint(key); 
                 if (p == null) {
                     p = (Paint) this.sectionPaints.get(key);
                     if (p == null) {
@@ -498,9 +496,9 @@
                 this.sectionPaints.put(key, p);
             }
         }
-
+        
     }
-
+    
     /**
      * Returns a collection of legend items for the pie chart.
      *
@@ -509,10 +507,10 @@
     public LegendItemCollection getLegendItems() {
 
         LegendItemCollection result = new LegendItemCollection();
-
+        
         if (this.dataset != null) {
             List keys = null;
-
+      
             prefetchSectionPaints();
             if (this.dataExtractOrder == TableOrder.BY_ROW) {
                 keys = this.dataset.getColumnKeys();
@@ -529,8 +527,8 @@
                     String label = key.toString();
                     String description = label;
                     Paint paint = (Paint) this.sectionPaints.get(key);
-                    LegendItem item = new LegendItem(label, description,
-                            null, null, Plot.DEFAULT_LEGEND_ITEM_CIRCLE,
+                    LegendItem item = new LegendItem(label, description, 
+                            null, null, Plot.DEFAULT_LEGEND_ITEM_CIRCLE, 
                             paint, Plot.DEFAULT_OUTLINE_STROKE, paint);
                     item.setDataset(getDataset());
                     result.add(item);
@@ -538,56 +536,56 @@
                 }
             }
             if (this.limit > 0.0) {
-                result.add(new LegendItem(this.aggregatedItemsKey.toString(),
-                        this.aggregatedItemsKey.toString(), null, null,
-                        Plot.DEFAULT_LEGEND_ITEM_CIRCLE,
+                result.add(new LegendItem(this.aggregatedItemsKey.toString(), 
+                        this.aggregatedItemsKey.toString(), null, null, 
+                        Plot.DEFAULT_LEGEND_ITEM_CIRCLE, 
                         this.aggregatedItemsPaint,
-                        Plot.DEFAULT_OUTLINE_STROKE,
+                        Plot.DEFAULT_OUTLINE_STROKE, 
                         this.aggregatedItemsPaint));
             }
         }
         return result;
     }
-
+    
     /**
-     * Tests this plot for equality with an arbitrary object.  Note that the
+     * Tests this plot for equality with an arbitrary object.  Note that the 
      * plot's dataset is not considered in the equality test.
-     *
+     * 
      * @param obj  the object (<code>null</code> permitted).
-     *
+     * 
      * @return <code>true</code> if this plot is equal to <code>obj</code>, and
      *     <code>false</code> otherwise.
      */
     public boolean equals(Object obj) {
         if (obj == this) {
-            return true;
+            return true;   
         }
         if (!(obj instanceof MultiplePiePlot)) {
-            return false;
+            return false;   
         }
         MultiplePiePlot that = (MultiplePiePlot) obj;
         if (this.dataExtractOrder != that.dataExtractOrder) {
-            return false;
+            return false;   
         }
         if (this.limit != that.limit) {
-            return false;
+            return false;   
         }
         if (!this.aggregatedItemsKey.equals(that.aggregatedItemsKey)) {
             return false;
         }
-        if (!PaintUtilities.equal(this.aggregatedItemsPaint,
+        if (!PaintUtilities.equal(this.aggregatedItemsPaint, 
                 that.aggregatedItemsPaint)) {
             return false;
         }
         if (!ObjectUtilities.equal(this.pieChart, that.pieChart)) {
-            return false;
+            return false;   
         }
         if (!super.equals(obj)) {
-            return false;
+            return false;   
         }
         return true;
     }
-
+    
     /**
      * Provides serialization support.
      *
@@ -608,12 +606,12 @@
      * @throws IOException  if there is an I/O error.
      * @throws ClassNotFoundException  if there is a classpath problem.
      */
-    private void readObject(ObjectInputStream stream)
+    private void readObject(ObjectInputStream stream) 
         throws IOException, ClassNotFoundException {
         stream.defaultReadObject();
         this.aggregatedItemsPaint = SerialUtilities.readPaint(stream);
         this.sectionPaints = new HashMap();
     }
 
-
+    
 }
