diff --git a/src/com/google/javascript/jscomp/Scope.java b/src/com/google/javascript/jscomp/Scope.java
index 8b6b1a50..b6037cb8 100644
--- a/src/com/google/javascript/jscomp/Scope.java
+++ b/src/com/google/javascript/jscomp/Scope.java
@@ -565,9 +565,6 @@ public class Scope
   /**
    * Return an iterable over all of the variables declared in this scope.
    */
-  Iterable<Var> getVarIterable() {
-    return vars.values();
-  }
 
   @Override
   public Iterable<Var> getReferences(Var var) {
diff --git a/src/com/google/javascript/jscomp/ScopedAliases.java b/src/com/google/javascript/jscomp/ScopedAliases.java
index 2b447cc3..840c171c 100644
--- a/src/com/google/javascript/jscomp/ScopedAliases.java
+++ b/src/com/google/javascript/jscomp/ScopedAliases.java
@@ -113,7 +113,7 @@ class ScopedAliases implements HotSwapCompilerPass {
       }
 
       // Remove the alias definitions.
-      for (Node aliasDefinition : traversal.getAliasDefinitionsInOrder()) {
+      for (Node aliasDefinition : traversal.getAliasDefinitions()) {
         if (aliasDefinition.getParent().getType() == Token.VAR &&
             aliasDefinition.getParent().hasOneChild()) {
           aliasDefinition.getParent().detachFromParent();
@@ -134,7 +134,7 @@ class ScopedAliases implements HotSwapCompilerPass {
       }
 
       if (traversal.getAliasUsages().size() > 0 ||
-          traversal.getAliasDefinitionsInOrder().size() > 0 ||
+          traversal.getAliasDefinitions().size() > 0 ||
           traversal.getScopeCalls().size() > 0) {
         compiler.reportCodeChange();
       }
@@ -183,7 +183,7 @@ class ScopedAliases implements HotSwapCompilerPass {
     // The job of this class is to collect these three data sets.
 
     // The order of this list determines the order that aliases are applied.
-    private final List<Node> aliasDefinitionsInOrder = Lists.newArrayList();
+    private final List<Node> aliasDefinitions = Lists.newArrayList();
 
     private final List<Node> scopeCalls = Lists.newArrayList();
 
@@ -196,8 +196,8 @@ class ScopedAliases implements HotSwapCompilerPass {
 
     private AliasTransformation transformation = null;
 
-    Collection<Node> getAliasDefinitionsInOrder() {
-      return aliasDefinitionsInOrder;
+    List<Node> getAliasDefinitions() {
+      return aliasDefinitions;
     }
 
     private List<AliasUsage> getAliasUsages() {
@@ -223,7 +223,6 @@ class ScopedAliases implements HotSwapCompilerPass {
       if (n != null && isCallToScopeMethod(n)) {
         transformation = transformationHandler.logAliasTransformation(
             n.getSourceFileName(), getSourceRegion(n));
-        findAliases(t);
       }
     }
 
@@ -269,84 +268,62 @@ class ScopedAliases implements HotSwapCompilerPass {
       hasErrors = true;
     }
 
-    private void findAliases(NodeTraversal t) {
-      Scope scope = t.getScope();
-      for (Var v : scope.getVarIterable()) {
-        Node n = v.getNode();
+    @Override
+    public void visit(NodeTraversal t, Node n, Node parent) {
+      if (isCallToScopeMethod(n)) {
+        if (preprocessorSymbolTable != null) {
+          preprocessorSymbolTable.addReference(n.getFirstChild());
+        }
+        if (!NodeUtil.isExpressionNode(parent)) {
+          report(t, n, GOOG_SCOPE_USED_IMPROPERLY);
+        }
+        if (n.getChildCount() != 2) {
+          report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS);
+        } else {
+          Node anonymousFnNode = n.getChildAtIndex(1);
+          if (!NodeUtil.isFunction(anonymousFnNode) ||
+              NodeUtil.getFunctionName(anonymousFnNode) != null ||
+              NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {
+            report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS);
+          } else {
+            scopeCalls.add(n);
+          }
+        }
+      }
+
+
+      if (t.getScopeDepth() == 2) {
         int type = n.getType();
-        Node parent = n.getParent();
-        if (parent.getType() == Token.VAR) {
+        if (type == Token.NAME && parent.getType() == Token.VAR) {
           if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {
             String name = n.getString();
-            Var aliasVar = scope.getVar(name);
+            Var aliasVar = t.getScope().getVar(name);
             aliases.put(name, aliasVar);
 
+            aliasDefinitions.add(n);
             String qualifiedName =
                 aliasVar.getInitialValue().getQualifiedName();
             transformation.addAlias(name, qualifiedName);
+            return;
           } else {
             // TODO(robbyw): Support using locals for private variables.
             report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());
           }
         }
-      }
-    }
 
-    private void validateScopeCall(NodeTraversal t, Node n, Node parent) {
-      if (preprocessorSymbolTable != null) {
-        preprocessorSymbolTable.addReference(n.getFirstChild());
-      }
-      if (!NodeUtil.isExpressionNode(parent)) {
-        report(t, n, GOOG_SCOPE_USED_IMPROPERLY);
-      }
-      if (n.getChildCount() != 2) {
         // The goog.scope call should have exactly 1 parameter.  The first
         // child is the "goog.scope" and the second should be the parameter.
-        report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS);
-      } else {
-        Node anonymousFnNode = n.getChildAtIndex(1);
-        if (!NodeUtil.isFunction(anonymousFnNode) ||
-            NodeUtil.getFunctionName(anonymousFnNode) != null ||
-            NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {
-          report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS);
-        } else {
-          scopeCalls.add(n);
-        }
-      }
-    }
 
-    @Override
-    public void visit(NodeTraversal t, Node n, Node parent) {
-      if (isCallToScopeMethod(n)) {
-        validateScopeCall(t, n, n.getParent());
-      }
 
-      if (t.getScopeDepth() < 2) {
-        return;
-      }
 
-      int type = n.getType();
-      Var aliasVar = null;
-      if (type == Token.NAME) {
-        String name = n.getString();
-        Var lexicalVar = t.getScope().getVar(n.getString());
-        if (lexicalVar != null && lexicalVar == aliases.get(name)) {
-          aliasVar = lexicalVar;
-        }
-      }
 
       // Validate the top level of the goog.scope block.
-      if (t.getScopeDepth() == 2) {
-        if (aliasVar != null && NodeUtil.isLValue(n)) {
-          if (aliasVar.getNode() == n) {
-            aliasDefinitionsInOrder.add(n);
 
             // Return early, to ensure that we don't record a definition
             // twice.
-            return;
-          } else {
-            report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
-          }
+        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&
+            n == parent.getFirstChild()) {
+          report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());
         }
 
         if (type == Token.RETURN) {
@@ -361,7 +338,12 @@ class ScopedAliases implements HotSwapCompilerPass {
       // Validate all descendent scopes of the goog.scope block.
       if (t.getScopeDepth() >= 2) {
         // Check if this name points to an alias.
-        if (aliasVar != null) {
+        if (n.getType() == Token.NAME) {
+          String name = n.getString();
+          Var aliasVar = aliases.get(name);
+
+          if (aliasVar != null &&
+              t.getScope().getVar(name) == aliasVar) {
           // Note, to support the transitive case, it's important we don't
           // clone aliasedNode here.  For example,
           // var g = goog; var d = g.dom; d.createElement('DIV');
@@ -370,6 +352,7 @@ class ScopedAliases implements HotSwapCompilerPass {
           // with <code>g.dom.createElement('DIV')</code>.
           Node aliasedNode = aliasVar.getInitialValue();
           aliasUsages.add(new AliasedNode(n, aliasedNode));
+          }
         }
 
         JSDocInfo info = n.getJSDocInfo();
