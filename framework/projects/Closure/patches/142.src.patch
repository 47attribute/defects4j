diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java
index c51297f5..605970d5 100644
--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java
+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java
@@ -1217,7 +1217,41 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {
     }
 
     if (left.getType() == Token.ARRAYLIT) {
-      return tryFoldArrayAccess(n, left, right);
+      if (right.getType() != Token.NUMBER) {
+        return n;
+      }
+
+      double index = right.getDouble();
+      int intIndex = (int) index;
+      if (intIndex != index) {
+        error(INVALID_GETELEM_INDEX_ERROR, right);
+        return n;
+      }
+
+      if (intIndex < 0) {
+        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
+        return n;
+      }
+
+      Node elem = left.getFirstChild();
+      for (int i = 0; elem != null && i < intIndex; i++) {
+        elem = elem.getNext();
+      }
+
+      if (elem == null) {
+        error(INDEX_OUT_OF_BOUNDS_ERROR, right);
+        return n;
+      }
+
+      if (elem.getType() == Token.EMPTY) {
+        elem = NodeUtil.newUndefinedNode(elem);
+      } else {
+        left.removeChild(elem);
+      }
+
+      n.getParent().replaceChild(n, elem);
+      reportCodeChange();
+      return elem;
     }
     return n;
   }
@@ -1331,7 +1365,10 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {
       return n;
     }
 
-    if (isAssignmentTarget(n)) {
+    Node parent = n.getParent();
+    if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)
+        || parent.getType() == Token.INC
+        || parent.getType() == Token.DEC) {
       // If GETPROP/GETELEM is used as assignment target the object literal is
       // acting as a temporary we can't fold it here:
       //    "{a:x}.a += 1" is not "x += 1"
