diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java
index abe01595..b5083826 100644
--- a/src/com/google/javascript/jscomp/CollapseProperties.java
+++ b/src/com/google/javascript/jscomp/CollapseProperties.java
@@ -452,8 +452,8 @@ class CollapseProperties implements CompilerPass {
     boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames();
 
     // Handle this name first so that nested object literals get unrolled.
-    if (n.canCollapse()) {
-      updateObjLitOrFunctionDeclaration(n, alias, canCollapseChildNames);
+    if (n.canCollapse() && canCollapseChildNames) {
+      updateObjLitOrFunctionDeclaration(n, alias);
     }
 
     if (n.props != null) {
@@ -571,30 +571,21 @@ class CollapseProperties implements CompilerPass {
    *     this name. (This is mostly passed for convenience; it's equivalent to
    *     n.canCollapseChildNames()).
    */
-  private void updateObjLitOrFunctionDeclaration(
-      Name n, String alias, boolean canCollapseChildNames) {
-    if (n.declaration == null) {
+  private void updateObjLitOrFunctionDeclaration(Name n, String alias) {
       // Some names do not have declarations, because they
       // are only defined in local scopes.
-      return;
-    }
-
-    if (n.declaration.getTwin() != null) {
       // Twin declarations will get handled when normal references
       // are handled.
-      return;
-    }
 
     switch (n.declaration.node.getParent().getType()) {
       case Token.ASSIGN:
-        updateObjLitOrFunctionDeclarationAtAssignNode(
-            n, alias, canCollapseChildNames);
+        updateObjLitOrFunctionDeclarationAtAssignNode(n, alias);
         break;
       case Token.VAR:
-        updateObjLitOrFunctionDeclarationAtVarNode(n, canCollapseChildNames);
+        updateObjLitOrFunctionDeclarationAtVarNode(n);
         break;
       case Token.FUNCTION:
-        updateFunctionDeclarationAtFunctionNode(n, canCollapseChildNames);
+        updateFunctionDeclarationAtFunctionNode(n);
         break;
     }
   }
@@ -608,7 +599,7 @@ class CollapseProperties implements CompilerPass {
    * @param alias The flattened name for {@code n} (e.g. "a", "a$b$c")
    */
   private void updateObjLitOrFunctionDeclarationAtAssignNode(
-      Name n, String alias, boolean canCollapseChildNames) {
+      Name n, String alias) {
     // NOTE: It's important that we don't add additional nodes
     // (e.g. a var node before the exprstmt) because the exprstmt might be
     // the child of an if statement that's not inside a block).
@@ -619,15 +610,13 @@ class CollapseProperties implements CompilerPass {
     Node varParent = ref.node.getAncestor(3);
     Node gramps = ref.node.getAncestor(2);
     boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;
-    boolean insertedVarNode = false;
 
     if (isObjLit && n.canEliminate()) {
       // Eliminate the object literal altogether.
       varParent.replaceChild(gramps, varNode);
       ref.node = null;
-      insertedVarNode = true;
 
-    } else if (!n.isSimpleName()) {
+    } else {
       // Create a VAR node to declare the name.
       if (rvalue.getType() == Token.FUNCTION) {
         checkForHosedThisReferences(rvalue, n.docInfo, n);
@@ -649,25 +638,20 @@ class CollapseProperties implements CompilerPass {
 
       // Update the node ancestry stored in the reference.
       ref.node = nameNode;
-      insertedVarNode = true;
     }
 
-    if (canCollapseChildNames) {
-      if (isObjLit) {
+    if (isObjLit) {
         declareVarsForObjLitValues(
             n, alias, rvalue,
             varNode, varParent.getChildBefore(varNode), varParent);
-      }
-
-      addStubsForUndeclaredProperties(n, alias, varParent, varNode);
     }
 
-    if (insertedVarNode) {
+    addStubsForUndeclaredProperties(n, alias, varParent, varNode);
       if (!varNode.hasChildren()) {
         varParent.removeChild(varNode);
-      }
-      compiler.reportCodeChange();
     }
+
+    compiler.reportCodeChange();
   }
 
   /**
@@ -700,12 +684,7 @@ class CollapseProperties implements CompilerPass {
    *
    * @param n An object representing a global name (e.g. "a")
    */
-  private void updateObjLitOrFunctionDeclarationAtVarNode(
-      Name n, boolean canCollapseChildNames) {
-    if (!canCollapseChildNames) {
-      return;
-    }
-
+  private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) {
     Ref ref = n.declaration;
     String name = ref.node.getString();
     Node rvalue = ref.node.getFirstChild();
@@ -747,12 +726,7 @@ class CollapseProperties implements CompilerPass {
    *
    * @param n An object representing a global name (e.g. "a")
    */
-  private void updateFunctionDeclarationAtFunctionNode(
-      Name n, boolean canCollapseChildNames) {
-    if (!canCollapseChildNames) {
-      return;
-    }
-
+  private void updateFunctionDeclarationAtFunctionNode(Name n) {
     Ref ref = n.declaration;
     String fnName = ref.node.getString();
     addStubsForUndeclaredProperties(
@@ -872,7 +846,6 @@ class CollapseProperties implements CompilerPass {
    */
   private int addStubsForUndeclaredProperties(
       Name n, String alias, Node parent, Node addAfter) {
-    Preconditions.checkState(n.canCollapseUnannotatedChildNames());
     Preconditions.checkArgument(NodeUtil.isStatementBlock(parent));
     Preconditions.checkNotNull(addAfter);
     int numStubs = 0;
