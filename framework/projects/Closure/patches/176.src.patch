diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java
index d58f80cb..ecee923d 100644
--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java
+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java
@@ -257,7 +257,7 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
     private final Node useCfgNode;
 
     // Number of uses of the variable within the current CFG node.
-    private int numUsesWithinCfgNode;
+    private int numUseWithinUseCfgNode;
 
     Candidate(String varName, Definition defMetadata,
         Node use, Node useCfgNode) {
@@ -327,7 +327,7 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
       // Finally we have to make sure that there are no more than one use
       // in the program and in the CFG node. Even when it is semantically
       // correctly inlining twice increases code size.
-      if (numUsesWithinCfgNode != 1) {
+      if (numUseWithinUseCfgNode != 1) {
         return false;
       }
 
@@ -471,41 +471,29 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
      * Computes the number of uses of the variable varName and store it in
      * numUseWithinUseCfgNode.
      */
-    private void getNumUseInUseCfgNode(final Node cfgNode) {
+    private void getNumUseInUseCfgNode(Node n) {
 
-      numUsesWithinCfgNode = 0;
       AbstractCfgNodeTraversalCallback gatherCb =
           new AbstractCfgNodeTraversalCallback() {
 
         @Override
         public void visit(NodeTraversal t, Node n, Node parent) {
-          if (n.isName() && n.getString().equals(varName)) {
+          if (n.isName() && n.getString().equals(varName) &&
             // We make a special exception when the entire cfgNode is a chain
             // of assignments, since in that case the assignment statements
             // will happen after the inlining of the right hand side.
             // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact
             //   and remove this special case.
-            if (parent.isAssign() && (parent.getFirstChild() == n)
-                && isAssignChain(parent, cfgNode)) {
+              !(parent.isAssign() &&
+               (parent.getFirstChild() == n))) {
               // Don't count lhs of top-level assignment chain
-              return;
-            } else {
-              numUsesWithinCfgNode++;
-            }
+            numUseWithinUseCfgNode++;
           }
         }
 
-        private boolean isAssignChain(Node child, Node ancestor) {
-          for (Node n = child; n != ancestor; n = n.getParent()) {
-            if (!n.isAssign()) {
-              return false;
-            }
-          }
-          return true;
-        }
       };
 
-      NodeTraversal.traverse(compiler, cfgNode, gatherCb);
+      NodeTraversal.traverse(compiler, n, gatherCb);
     }
   }
 
@@ -539,7 +527,7 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback
    */
   private static boolean checkLeftOf(
       Node n, Node expressionRoot, Predicate<Node> predicate) {
-    for (Node p = n; p != expressionRoot; p = p.getParent()) {
+    for (Node p = n.getParent(); p != expressionRoot; p = p.getParent()) {
       for (Node cur = p.getParent().getFirstChild(); cur != p;
           cur = cur.getNext()) {
         if (predicate.apply(cur)) {
